<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Storage Snapshots</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
        Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background: #f9f9f9;
      margin: 0;
      padding: 2rem;
      color: #333;

      min-height: 100vh;

      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .container {
      margin: auto;
      background: white;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      border: 1px solid rgba(0,0,0,.1);
    }

    h1, h2 {
      margin: 0;
      color: #222;
    }

    .snapshot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      white-space: nowrap;

      gap: 2rem;
    }

    button {
      cursor: pointer;
      border: none;
      background: #007bff;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-size: 0.9rem;
      transition: background 0.25s ease;
    }

    button:hover {
      background: #0056b3;
    }

    #snapshotBtn {
      background: #28a745;
    }

    #snapshotBtn:hover {
      background: #1e7e34;
    }

    .comment-label {
      display: block;
      font-size: 0.9rem;
      font-weight: 700;

      margin-top: 1rem;
      margin-bottom: 0.5rem;
    }

    .comment-box {
      padding: 0.5rem;

      background: #efefef;
      border-radius: 0.5rem;

      border: 1.5px solid #e4e4e4;

      margin-bottom: 2rem;

      outline: none;

      transition: 0.1s;
    }

    .comment-box:hover:not(:focus) {
      border-color: #bcbcbc;
    }

    .comment-box:focus {
      border-color: #76adbc;
    }

    .snapshot-item {
      display: flex;
      align-items: center;
      margin-top: 0.75rem;
      background: #fafafa;
      padding: 0.5rem 1rem;
      gap: 0.5rem;
    }

    .snapshot-name {
      flex: 1;
      word-wrap: break-word;

      font-size: 0.85rem;
      font-weight: 500;
    }

    .snapshot-item-comment {
      padding: 0.5rem 1rem;
      border-top: 1px solid #e4e4e4;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="snapshot-header">
      <h2>Storage Snapshot Manager</h2>
      <button id="snapshotBtn">Save</button>
      <button id="snapshotBtn2">Load</button>
      <label>
        <input type="checkbox" id="saveAuthorization" />
        Save auth
      </label>
    </div>
    
    <div>
      <label class="comment-label" for="snapshotComment">Comment</label>
      <div class="comment-box" id="snapshotComment" contenteditable>
    
      </div>
      </div>
      
      <h3>Saved Snapshots</h3>
      <div id="snapshotList"></div>
  </div>

  <script>
    // Actively unregister any existing service worker
    if (navigator.serviceWorker) {
      navigator.serviceWorker.getRegistrations().then(regs => {
        for (let reg of regs) {
          reg.unregister().then((success) => {
            success &&
              window.location.reload();
          });
        }
      });
    }

    const snapshotBtn = document.getElementById('snapshotBtn');
    const snapshotBtnLoad = document.getElementById('snapshotBtn2');
    const snapshotList = document.getElementById('snapshotList');
    const snapshotComment = document.getElementById('snapshotComment');
    const saveAuthorization = document.getElementById('saveAuthorization');

    const IS_PRODUCTION = new URL(location.href).hostname === 'web.telegram.org';

    snapshotBtn.addEventListener('click', async() => {
      const snapshot = await takeSnapshot();
      // * if production, save locally to user's computer, otherwise send it to server
      if(IS_PRODUCTION) {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([JSON.stringify(snapshot, jsonReplacer)]));
        a.download = `snapshot-${new Date().toISOString()}.json`;
        a.click();
        return;
      }

      const res = await fetch('/api/snapshots', {
        method: 'POST',
        headers: {'Content-Type': 'text/plain'},
        body: JSON.stringify(snapshot, jsonReplacer)
      });
      if(res.ok) {
        alert('Snapshot saved successfully!');
        loadSnapshots();
      } else {
        alert('Something went wrong while saving the snapshot: ' + res.statusText);
      }
    });

    // * choose local file to load
    snapshotBtnLoad.addEventListener('click', async() => {
      const file = await requestFile('application/json');
      if(!file) return;

      const text = await file.text();
      const snapshot = JSON.parse(text, jsonReviver);
      await loadSnapshotFile(snapshot);
    });

    snapshotComment.innerHTML = `Taken on ${new Date().toDateString()}`;

    async function takeSnapshot() {
      const localStorageData = {};
      const shouldSaveAuth = saveAuthorization.checked;
      for(let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        // Skip keys starting with 'account', 'dc', 't_account' or 't_dc' if authorization saving is disabled
        if(!shouldSaveAuth && (key.startsWith('account') || key.startsWith('dc') || key.startsWith('t_account') || key.startsWith('t_dc'))) {
          continue;
        }
        localStorageData[key] = localStorage.getItem(key);
      }

      const indexedDBData = {};
      const dbs = await indexedDB.databases?.() || [];

      for(const {name} of dbs) {
        if(!name) continue;

        indexedDBData[name] = {};
        const db = await openDB(name);

        for(const storeName of db.objectStoreNames) {
          const tx = db.transaction(storeName, 'readonly');
          const store = tx.objectStore(storeName);
          const entries = await getAllEntries(store);
          indexedDBData[name][storeName] = entries;
        }

        db.close();
      }

      return {
        comment: snapshotComment.innerHTML,
        localStorage: localStorageData,
        indexedDB: indexedDBData
      };
    }

    function openDB(name) {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(name);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    // function getAllRecords(store) {
    //   return new Promise((resolve, reject) => {
    //     const request = store.getAll();
    //     request.onsuccess = () => resolve(request.result);
    //     request.onerror = () => reject(request.error);
    //   });
    // }

    async function loadSnapshots() {
      const res = await fetch('/api/snapshots');
      const snapshots = await res.json();

      snapshotList.innerHTML = '';

      snapshots.forEach(({name, comment}) => {
        const li = document.createElement('div');
        li.classList.add('snapshot-item')

        const nameEl = document.createElement('span');
        nameEl.textContent = name;
        nameEl.classList.add('snapshot-name');

        const commentEl = document.createElement('div');
        commentEl.innerHTML = comment;
        commentEl.classList.add('snapshot-item-comment');

        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load';
        loadBtn.onclick = () => loadSnapshot(name);

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.onclick = async() => {
          const confirmed = confirm('Are you sure you want to delete this snapshot?');
          if(!confirmed) return;
          await fetch(`/api/snapshots/${name}`, {method: 'DELETE'});
          alert('Snapshot successfully deleted');
          loadSnapshots();
        };

        li.appendChild(nameEl)
        li.appendChild(loadBtn);
        li.appendChild(deleteBtn);
        snapshotList.appendChild(li);
        if((comment || '').trim?.()) snapshotList.appendChild(commentEl);
      });
    }

    window.onload = loadSnapshots;

    async function loadSnapshot(filename) {
      if(!confirm(`Are you sure you want to load snapshot "${filename}"? This will overwrite your current storage.`)) {
        return;
      }

      const res = await fetch(`/api/snapshots/${filename}`);
      if(!res.ok) {
        alert('Failed to load snapshot');
        return;
      }

      const snapshotText = await res.text();
      const snapshot = JSON.parse(snapshotText, jsonReviver);
      await loadSnapshotFile(snapshot);
    }

    async function loadSnapshotFile(snapshot) {
      // Restore localStorage
      localStorage.clear();
      for(const [key, value] of Object.entries(snapshot.localStorage || {})) {
        localStorage.setItem(key, value);
      }

      // Restore indexedDB
      await clearAllIndexedDB();

      for(const [dbName, stores] of Object.entries(snapshot.indexedDB || {})) {
        await restoreIndexedDB(dbName, stores);
      }

      alert('Snapshot loaded successfully!');
    }

    function clearAllIndexedDB() {
      return new Promise(async(resolve) => {
        const dbs = await indexedDB.databases?.() || [];
        let count = dbs.length;

        if(count === 0) resolve();

        for(const {name} of dbs) {
          if(!name) {
            count--;
            if(count === 0) resolve();
            continue;
          }
          const req = indexedDB.deleteDatabase(name);
          req.onsuccess = () => {
            count--;
            if(count === 0) resolve();
          };
          req.onerror = () => {
            console.warn(`Failed to delete indexedDB ${name}`);
            count--;
            if(count === 0) resolve();
          };
        }
      });
    }

    function restoreIndexedDB(dbName, stores) {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(dbName);

        req.onupgradeneeded = (event) => {
          const db = event.target.result;

          // Delete existing object stores if any
          Array.from(db.objectStoreNames).forEach(storeName => {
            db.deleteObjectStore(storeName);
          });

          // Create stores from snapshot
          for(const storeName of Object.keys(stores)) {
            db.createObjectStore(storeName/* , {keyPath: 'id', autoIncrement: false} */);
          }
        };

        req.onsuccess = async(event) => {
          const db = event.target.result;

          // Write all entries to each store
          try {
            for(const [storeName, entries] of Object.entries(stores)) {
              const tx = db.transaction(storeName, 'readwrite');
              const store = tx.objectStore(storeName);

              for(const entry of entries) {
                store.put(entry.value, entry.key);
              }

              await tx.complete; // some browsers support promise on tx.complete, others don't
            }
          } catch(e) {
            console.error('Error restoring indexedDB data', e);
          }

          db.close();
          resolve();
        };

        req.onerror = () => reject(req.error);
      });
    }

    function jsonReplacer(key, value) {
      if(value instanceof Uint8Array) {
        return {
          __type: 'Uint8Array',
          data: Array.from(value) // convert to normal array for JSON
        };
      }
      return value;
    }

    function jsonReviver(key, value) {
      if(value && value.__type === 'Uint8Array' && Array.isArray(value.data)) {
        return new Uint8Array(value.data);
      }
      return value;
    }

    function getAllEntries(store) {
      return new Promise((resolve, reject) => {
        const entries = [];
        const request = store.openCursor();
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if(cursor) {
            entries.push({key: cursor.key, value: cursor.value});
            cursor.continue();
          } else {
            resolve(entries);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }

    function requestFile(accept) {
      return new Promise((resolve) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = accept;
        input.onchange = (e) => {
          resolve(e.target.files[0] || null);
        };
        input.oncancel = () => {
          resolve(null);
        };
        input.click();
      });
    }
  </script>
</body>

</html>
