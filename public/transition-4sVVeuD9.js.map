{"version":3,"file":"transition-4sVVeuD9.js","sources":["../src/vendor/solid-transition-group/common.ts","../node_modules/.pnpm/@solid-primitives+transition-group@1.0.3_solid-js@1.8.7/node_modules/@solid-primitives/transition-group/dist/index.js","../node_modules/.pnpm/@solid-primitives+refs@1.0.5_solid-js@1.8.7/node_modules/@solid-primitives/refs/dist/index.js","../src/vendor/solid-transition-group/transition.ts"],"sourcesContent":["// https://github.com/solidjs-community/solid-transition-group\n\nimport {createMemo} from 'solid-js';\nimport type {TransitionEvents, TransitionProps} from '@vendor/solid-transition-group/transition';\n// import type {TransitionGroupProps} from '@vendor/solid-transition-group/transitionGroup';\n\nexport function createClassnames(props: TransitionProps/*  & TransitionGroupProps */) {\n  return createMemo(() => {\n    const name = props.name || 's';\n    return {\n      enterActive: (props.enterActiveClass || name + '-enter-active').split(' '),\n      enter: (props.enterClass || name + '-enter').split(' '),\n      enterTo: (props.enterToClass || name + '-enter-to').split(' '),\n      exitActive: (props.exitActiveClass || name + '-exit-active').split(' '),\n      exit: (props.exitClass || name + '-exit').split(' '),\n      exitTo: (props.exitToClass || name + '-exit-to').split(' ')\n      // move: (props.moveClass || name + '-move').split(' ')\n    };\n  });\n}\n\n// https://github.com/solidjs-community/solid-transition-group/issues/12\n// for the css transition be triggered properly on firefox\n// we need to wait for two frames before changeing classes\nexport function nextFrame(fn: () => void) {\n  requestAnimationFrame(() => requestAnimationFrame(fn));\n}\n\n/**\n * Run an enter transition on an element - common for both Transition and TransitionGroup\n */\nexport function enterTransition(\n  classes: ReturnType<ReturnType<typeof createClassnames>>,\n  events: TransitionEvents,\n  el: Element,\n  done?: VoidFunction,\n  duration?: number\n) {\n  const {onBeforeEnter, onEnter, onAfterEnter} = events;\n\n  let timeout: number;\n\n  // before the elements are added to the DOM\n  onBeforeEnter?.(el);\n\n  el.classList.add(...classes.enter);\n  el.classList.add(...classes.enterActive);\n\n  // after the microtask the elements will be added to the DOM\n  // and onEnter will be called in the same frame\n  queueMicrotask(() => {\n    // Don't animate element if it's not in the DOM\n    // This can happen when elements are changed under Suspense\n    if(!el.parentNode) return done?.();\n\n    onEnter?.(el, () => endTransition());\n  });\n\n  nextFrame(() => {\n    el.classList.remove(...classes.enter);\n    el.classList.add(...classes.enterTo);\n\n    if(!onEnter || onEnter.length < 2) {\n      el.addEventListener('transitionend', endTransition);\n      el.addEventListener('animationend', endTransition);\n\n      if(duration !== undefined) {\n        timeout = window.setTimeout(() => endTransition(), duration);\n      }\n    }\n  });\n\n  function endTransition(e?: Event) {\n    if(!e || e.target === el) {\n      clearTimeout(timeout);\n      done?.(); // starts exit transition in \"in-out\" mode\n      el.removeEventListener('transitionend', endTransition);\n      el.removeEventListener('animationend', endTransition);\n      el.classList.remove(...classes.enterActive);\n      el.classList.remove(...classes.enterTo);\n      onAfterEnter?.(el);\n    }\n  }\n}\n\n/**\n * Run an exit transition on an element - common for both Transition and TransitionGroup\n */\nexport function exitTransition(\n  classes: ReturnType<ReturnType<typeof createClassnames>>,\n  events: TransitionEvents,\n  el: Element,\n  done?: VoidFunction,\n  duration?: number\n) {\n  const {onBeforeExit, onExit, onAfterExit} = events;\n\n  // Don't animate element if it's not in the DOM\n  // This can happen when elements are changed under Suspense\n  if(!el.parentNode) return done?.();\n\n  let timeout: number;\n\n  onBeforeExit?.(el);\n\n  el.classList.add(...classes.exit);\n  el.classList.add(...classes.exitActive);\n\n  onExit?.(el, () => endTransition());\n\n  nextFrame(() => {\n    el.classList.remove(...classes.exit);\n    el.classList.add(...classes.exitTo);\n\n    if(!onExit || onExit.length < 2) {\n      el.addEventListener('transitionend', endTransition);\n      el.addEventListener('animationend', endTransition);\n\n      if(duration !== undefined) {\n        timeout = window.setTimeout(() => endTransition(), duration);\n      }\n    }\n  });\n\n  function endTransition(e?: Event) {\n    if(!e || e.target === el) {\n      // calling done() will remove element from the DOM,\n      // but also trigger onChange callback in <TransitionGroup>.\n      // Which is why the classes need to removed afterwards,\n      // so that removing them won't change el styles when for the move transition\n      clearTimeout(timeout);\n      done?.();\n      el.removeEventListener('transitionend', endTransition);\n      el.removeEventListener('animationend', endTransition);\n      el.classList.remove(...classes.exitActive);\n      el.classList.remove(...classes.exitTo);\n      onAfterExit?.(el);\n    }\n  }\n}\n","import { untrack, createSignal, useTransition, createComputed, batch, createMemo, $TRACK } from 'solid-js';\nimport { isServer } from 'solid-js/web';\n\n// src/index.ts\nvar noop = () => {\n};\nvar noopTransition = (el, done) => done();\nfunction createSwitchTransition(source, options) {\n  const initSource = untrack(source);\n  const initReturned = initSource ? [initSource] : [];\n  if (isServer) {\n    return () => initReturned;\n  }\n  const { onEnter = noopTransition, onExit = noopTransition } = options;\n  const [returned, setReturned] = createSignal(\n    options.appear ? [] : initReturned\n  );\n  const [isTransitionPending] = useTransition();\n  let next;\n  let isExiting = false;\n  function exitTransition(el, after) {\n    if (!el)\n      return after && after();\n    isExiting = true;\n    onExit(el, () => {\n      batch(() => {\n        isExiting = false;\n        setReturned((p) => p.filter((e) => e !== el));\n        after && after();\n      });\n    });\n  }\n  function enterTransition(after) {\n    const el = next;\n    if (!el)\n      return after && after();\n    next = void 0;\n    setReturned((p) => [el, ...p]);\n    onEnter(el, after ?? noop);\n  }\n  const triggerTransitions = options.mode === \"out-in\" ? (\n    // exit -> enter\n    (prev) => isExiting || exitTransition(prev, enterTransition)\n  ) : options.mode === \"in-out\" ? (\n    // enter -> exit\n    (prev) => enterTransition(() => exitTransition(prev))\n  ) : (\n    // exit & enter\n    (prev) => {\n      exitTransition(prev);\n      enterTransition();\n    }\n  );\n  createComputed(\n    (prev) => {\n      const el = source();\n      if (untrack(isTransitionPending)) {\n        isTransitionPending();\n        return prev;\n      }\n      if (el !== prev) {\n        next = el;\n        batch(() => untrack(() => triggerTransitions(prev)));\n      }\n      return el;\n    },\n    options.appear ? void 0 : initSource\n  );\n  return returned;\n}\nfunction createListTransition(source, options) {\n  const initSource = untrack(source);\n  if (isServer) {\n    const copy = initSource.slice();\n    return () => copy;\n  }\n  const { onChange } = options;\n  let prevSet = new Set(options.appear ? void 0 : initSource);\n  const exiting = /* @__PURE__ */ new WeakSet();\n  const [toRemove, setToRemove] = createSignal([], { equals: false });\n  const [isTransitionPending] = useTransition();\n  const finishRemoved = options.exitMethod === \"remove\" ? noop : (els) => {\n    setToRemove((p) => (p.push.apply(p, els), p));\n    for (const el of els)\n      exiting.delete(el);\n  };\n  const handleRemoved = options.exitMethod === \"remove\" ? noop : options.exitMethod === \"keep-index\" ? (els, el, i) => els.splice(i, 0, el) : (els, el) => els.push(el);\n  return createMemo(\n    (prev) => {\n      const elsToRemove = toRemove();\n      const sourceList = source();\n      sourceList[$TRACK];\n      if (untrack(isTransitionPending)) {\n        isTransitionPending();\n        return prev;\n      }\n      if (elsToRemove.length) {\n        const next = prev.filter((e) => !elsToRemove.includes(e));\n        elsToRemove.length = 0;\n        onChange({ list: next, added: [], removed: [], unchanged: next, finishRemoved });\n        return next;\n      }\n      return untrack(() => {\n        const nextSet = new Set(sourceList);\n        const next = sourceList.slice();\n        const added = [];\n        const removed = [];\n        const unchanged = [];\n        for (const el of sourceList) {\n          (prevSet.has(el) ? unchanged : added).push(el);\n        }\n        let nothingChanged = !added.length;\n        for (let i = 0; i < prev.length; i++) {\n          const el = prev[i];\n          if (!nextSet.has(el)) {\n            if (!exiting.has(el)) {\n              removed.push(el);\n              exiting.add(el);\n            }\n            handleRemoved(next, el, i);\n          }\n          if (nothingChanged && el !== next[i])\n            nothingChanged = false;\n        }\n        if (!removed.length && nothingChanged)\n          return prev;\n        onChange({ list: next, added, removed, unchanged, finishRemoved });\n        prevSet = nextSet;\n        return next;\n      });\n    },\n    options.appear ? [] : initSource.slice()\n  );\n}\n\nexport { createListTransition, createSwitchTransition };\n","import { chain, arrayEquals } from '@solid-primitives/utils';\nimport { createMemo, children, createComputed, untrack, onCleanup } from 'solid-js';\nimport { isServer } from 'solid-js/web';\n\n// src/index.ts\nfunction mergeRefs(...refs) {\n  return chain(refs);\n}\nvar defaultElementPredicate = isServer ? (item) => item != null && typeof item === \"object\" && \"t\" in item : (item) => item instanceof Element;\nfunction getResolvedElements(value, predicate) {\n  if (predicate(value))\n    return value;\n  if (typeof value === \"function\" && !value.length)\n    return getResolvedElements(value(), predicate);\n  if (Array.isArray(value)) {\n    const results = [];\n    for (const item of value) {\n      const result = getResolvedElements(item, predicate);\n      if (result)\n        Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results.length ? results : null;\n  }\n  return null;\n}\nfunction resolveElements(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n  const children2 = createMemo(fn);\n  const memo = createMemo(\n    () => getResolvedElements(children2(), isServer ? serverPredicate : predicate)\n  );\n  memo.toArray = () => {\n    const value = memo();\n    return Array.isArray(value) ? value : value ? [value] : [];\n  };\n  return memo;\n}\nfunction getFirstChild(value, predicate) {\n  if (predicate(value))\n    return value;\n  if (typeof value === \"function\" && !value.length)\n    return getFirstChild(value(), predicate);\n  if (Array.isArray(value)) {\n    for (const item of value) {\n      const result = getFirstChild(item, predicate);\n      if (result)\n        return result;\n    }\n  }\n  return null;\n}\nfunction resolveFirst(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n  const children2 = createMemo(fn);\n  return createMemo(() => getFirstChild(children2(), isServer ? serverPredicate : predicate));\n}\nfunction Refs(props) {\n  if (isServer) {\n    return props.children;\n  }\n  const cb = props.ref, resolved = children(() => props.children);\n  let prev = [];\n  createComputed(() => {\n    const els = resolved.toArray().filter(defaultElementPredicate);\n    if (!arrayEquals(prev, els))\n      untrack(() => cb(els));\n    prev = els;\n  }, []);\n  onCleanup(() => prev.length && cb([]));\n  return resolved;\n}\nfunction Ref(props) {\n  if (isServer) {\n    return props.children;\n  }\n  const cb = props.ref, resolved = children(() => props.children);\n  let prev;\n  createComputed(() => {\n    const el = resolved.toArray().find(defaultElementPredicate);\n    if (el !== prev)\n      untrack(() => cb(el));\n    prev = el;\n  });\n  onCleanup(() => prev && cb(void 0));\n  return resolved;\n}\n\nexport { Ref, Refs, defaultElementPredicate, getFirstChild, getResolvedElements, mergeRefs, resolveElements, resolveFirst };\n","// https://github.com/solidjs-community/solid-transition-group\n\nimport {type FlowComponent, type JSX} from 'solid-js';\nimport {createClassnames, enterTransition, exitTransition} from '@vendor/solid-transition-group/common';\nimport {createSwitchTransition} from '@solid-primitives/transition-group';\nimport {resolveFirst} from '@solid-primitives/refs';\n\nexport type TransitionEvents = {\n  /**\n   * Function called before the enter transition starts.\n   * The {@link element} is not yet rendered.\n   */\n  onBeforeEnter?: (element: Element) => void;\n  /**\n   * Function called when the enter transition starts.\n   * The {@link element} is rendered to the DOM.\n   *\n   * Call {@link done} to end the transition - removes the enter classes,\n   * and calls {@link TransitionEvents.onAfterEnter}.\n   * If the parameter for {@link done} is not provided, it will be called on `transitionend` or `animationend`.\n   */\n  onEnter?: (element: Element, done: () => void) => void;\n  /**\n   * Function called after the enter transition ends.\n   * The {@link element} is removed from the DOM.\n   */\n  onAfterEnter?: (element: Element) => void;\n  /**\n   * Function called before the exit transition starts.\n   * The {@link element} is still rendered, exit classes are not yet applied.\n   */\n  onBeforeExit?: (element: Element) => void;\n  /**\n   * Function called when the exit transition starts, after the exit classes are applied\n   * ({@link TransitionProps.enterToClass} and {@link TransitionProps.exitActiveClass}).\n   * The {@link element} is still rendered.\n   *\n   * Call {@link done} to end the transition - removes exit classes,\n   * calls {@link TransitionEvents.onAfterExit} and removes the element from the DOM.\n   * If the parameter for {@link done} is not provided, it will be called on `transitionend` or `animationend`.\n   */\n  onExit?: (element: Element, done: () => void) => void;\n  /**\n   * Function called after the exit transition ends.\n   * The {@link element} is removed from the DOM.\n   */\n  onAfterExit?: (element: Element) => void;\n};\n\n/**\n * Props for the {@link Transition} component.\n */\nexport type TransitionProps = TransitionEvents & {\n  /**\n   * Used to automatically generate transition CSS class names.\n   * e.g. `name: 'fade'` will auto expand to `.fade-enter`, `.fade-enter-active`, etc.\n   * Defaults to `\"s\"`.\n   */\n  name?: string;\n  /**\n   * CSS class applied to the entering element for the entire duration of the enter transition.\n   * Defaults to `\"s-enter-active\"`.\n   */\n  enterActiveClass?: string;\n  /**\n   * CSS class applied to the entering element at the start of the enter transition, and removed the frame after.\n   * Defaults to `\"s-enter\"`.\n   */\n  enterClass?: string;\n  /**\n   * CSS class applied to the entering element after the enter transition starts.\n   * Defaults to `\"s-enter-to\"`.\n   */\n  enterToClass?: string;\n  /**\n   * CSS class applied to the exiting element for the entire duration of the exit transition.\n   * Defaults to `\"s-exit-active\"`.\n   */\n  exitActiveClass?: string;\n  /**\n   * CSS class applied to the exiting element at the start of the exit transition, and removed the frame after.\n   * Defaults to `\"s-exit\"`.\n   */\n  exitClass?: string;\n  /**\n   * CSS class applied to the exiting element after the exit transition starts.\n   * Defaults to `\"s-exit-to\"`.\n   */\n  exitToClass?: string;\n  /**\n   * Whether to apply transition on initial render. Defaults to `false`.\n   */\n  appear?: boolean;\n  /**\n   * Controls the timing sequence of leaving/entering transitions.\n   * Available modes are `\"outin\"` and `\"inout\"`;\n   * Defaults to simultaneous.\n   */\n  mode?: 'inout' | 'outin';\n  /**\n   * The duration of the transition, in milliseconds.\n   * Defaults to `300`.\n   */\n  duration?: number;\n};\n\nconst TRANSITION_MODE_MAP = {\n  inout: 'in-out',\n  outin: 'out-in'\n} as const;\n\n/**\n * The `<Transition>` component lets you apply enter and leave animations on element passed to `props.children`.\n *\n * It only supports transitioning a single element at a time.\n *\n * @param props {@link TransitionProps}\n */\nexport const Transition: FlowComponent<TransitionProps> = (props) => {\n  const classnames = createClassnames(props);\n\n  return createSwitchTransition(\n    resolveFirst(() => props.children),\n    {\n      mode: TRANSITION_MODE_MAP[props.mode!],\n      appear: props.appear,\n      onEnter(el, done) {\n        enterTransition(classnames(), props, el, done, props.duration);\n      },\n      onExit(el, done) {\n        exitTransition(classnames(), props, el, done, props.duration);\n      }\n    }\n  ) as unknown as JSX.Element;\n};\n"],"names":["createClassnames","props","createMemo","name","nextFrame","fn","enterTransition","classes","events","el","done","duration","onBeforeEnter","onEnter","onAfterEnter","timeout","endTransition","e","exitTransition","onBeforeExit","onExit","onAfterExit","noop","noopTransition","createSwitchTransition","source","options","initSource","untrack","initReturned","returned","setReturned","createSignal","isTransitionPending","useTransition","next","isExiting","after","batch","p","triggerTransitions","prev","createComputed","defaultElementPredicate","item","getResolvedElements","value","predicate","results","result","resolveElements","serverPredicate","children2","memo","getFirstChild","resolveFirst","TRANSITION_MODE_MAP","Transition","classnames"],"mappings":"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","x_google_ignoreList":[1,2]}