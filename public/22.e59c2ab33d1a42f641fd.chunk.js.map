{"version":3,"sources":["webpack:///./src/helpers/object/getDeepProperty.ts","webpack:///./src/helpers/compareVersion.ts","webpack:///./src/helpers/object/validateInitObject.ts","webpack:///./src/lib/appManagers/appStateManager.ts","webpack:///./src/helpers/getTimeFormat.ts","webpack:///./src/helpers/object/setDeepProperty.ts"],"names":["getDeepProperty","object","key","splitted","split","o","forEach","compareVersion","v1","v2","s1","s2","i","length","validateInitObject","initObject","currentObject","onReplace","previousKey","STATE_VERSION","version","BUILD","build","STATE_INIT","allDialogsLoaded","pinnedOrders","contactsList","updates","filters","maxSeenMsgId","stateCreatedTime","Date","now","recentEmoji","topPeersCache","recentSearch","authState","_","hiddenPinnedMessages","settings","messagesTextSize","distanceUnit","sendShortcut","animationsEnabled","autoDownload","photo","contacts","private","groups","channels","video","file","autoDownloadNew","file_size_max","pFlags","video_preload_large","audio_preload_next","photo_size_max","video_size_max","video_upload_maxbitrate","autoPlay","gifs","videos","stickers","suggest","loop","emoji","big","themes","name","background","blur","slug","color","highlightningColor","intensity","id","theme","notifications","sound","timeFormat","toLocaleString","match","keepSigned","chatContextMenuHintWasShown","stateId","notifySettings","ALL_KEYS","Object","keys","REFRESH_KEYS","super","log","logger","neededPeers","Map","singlePeerMap","storages","users","chats","dialogs","storagesResults","storage","stateStorage","this","loadSavedState","rootScope","addEventListener","requestPeerSingle","myId","loaded","console","time","Promise","resolve","storagesKeys","storagesPromises","map","getAll","promises","get","concat","sessionStorage","all","then","arr","state","value","undefined","pushToState","copy","splice","auth","shift","shiftedWebKAuth","push","values","dcID","baseDcId","date","toPeerId","obj","idx","set","dispatchEvent","preserve","state_id","s","r","hasOwnProperty","nightTheme","find","t","autoDownloadSettings","oldTypes","mediaType","peerTypeSettings","peerType","missingKey","result","migrated","type","newTheme","newVersion","timeEnd","catch","slice","join","pop","setDeepProperty","first","direct","setKeyValueToStorage","peerId","limit","has","Set","add","keepPeerSingle","keepPeerIdSingle","requestPeer","existsPeerId","delete","size","appStateManager"],"mappings":"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","file":"22.e59c2ab33d1a42f641fd.chunk.js","sourcesContent":["export default function getDeepProperty(object: any, key: string) {\n  const splitted = key.split('.');\n  let o: any = object;\n  splitted.forEach(key => {\n    if(!key) {\n      return;\n    }\n    \n    // @ts-ignore\n    o = o[key];\n  });\n  \n  return o;\n}\n","export default function compareVersion(v1: string, v2: string): number {\n  v1 = v1.split(' ', 1)[0];\n  v2 = v2.split(' ', 1)[0];\n  const s1 = v1.split('.');\n  const s2 = v2.split('.');\n\n  for(let i = 0; i < s1.length; ++i) {\n    const v1 = +s1[i];\n    const v2 = +s2[i];\n    if(v1 > v2) return 1;\n    else if(v1 < v2) return -1;\n  }\n\n  return 0;\n}\n","import copy from \"./copy\";\nimport isObject from \"./isObject\";\n\nexport default function validateInitObject(initObject: any, currentObject: any, onReplace?: (key: string) => void, previousKey?: string) {\n  for(const key in initObject) {\n    if(typeof(currentObject[key]) !== typeof(initObject[key])) {\n      currentObject[key] = copy(initObject[key]);\n      onReplace && onReplace(previousKey || key);\n    } else if(isObject(initObject[key])) {\n      validateInitObject(initObject[key], currentObject[key], onReplace, previousKey || key);\n    }\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type { Dialog } from './appMessagesManager';\nimport { NULL_PEER_ID, UserAuth } from '../mtproto/mtproto_config';\nimport type { MyTopPeer, TopPeerType, User } from './appUsersManager';\nimport type { AuthState } from '../../types';\nimport type FiltersStorage from '../storages/filters';\nimport type DialogsStorage from '../storages/dialogs';\nimport EventListenerBase from '../../helpers/eventListenerBase';\nimport rootScope from '../rootScope';\nimport stateStorage from '../stateStorage';\nimport { logger } from '../logger';\nimport App from '../../config/app';\nimport DEBUG, { MOUNT_CLASS_TO } from '../../config/debug';\nimport AppStorage from '../storage';\nimport { AutoDownloadSettings, Chat, NotifyPeer, PeerNotifySettings } from '../../layer';\nimport { IS_MOBILE } from '../../environment/userAgent';\nimport DATABASE_STATE from '../../config/databases/state';\nimport sessionStorage from '../sessionStorage';\nimport { nextRandomUint } from '../../helpers/random';\nimport compareVersion from '../../helpers/compareVersion';\nimport getTimeFormat from '../../helpers/getTimeFormat';\nimport copy from '../../helpers/object/copy';\nimport setDeepProperty from '../../helpers/object/setDeepProperty';\nimport validateInitObject from '../../helpers/object/validateInitObject';\n\nconst REFRESH_EVERY = 24 * 60 * 60 * 1000; // 1 day\n// const REFRESH_EVERY = 1e3;\n//const REFRESH_EVERY_WEEK = 24 * 60 * 60 * 1000 * 7; // 7 days\nconst STATE_VERSION = App.version;\nconst BUILD = App.build;\n\nexport type Background = {\n  type?: 'color' | 'image' | 'default', // ! DEPRECATED\n  blur: boolean,\n  highlightningColor?: string,\n  color?: string,     \n  slug?: string,        // image slug\n  intensity?: number,   // pattern intensity\n  id: string | number,  // wallpaper id\n};\n\nexport type Theme = {\n  name: 'day' | 'night' | 'system',\n  background: Background\n};\n\nexport type AutoDownloadPeerTypeSettings = {\n  contacts: boolean,\n  private: boolean,\n  groups: boolean,\n  channels: boolean\n};\n\nexport type State = {\n  allDialogsLoaded: DialogsStorage['allDialogsLoaded'],\n  pinnedOrders: DialogsStorage['pinnedOrders'],\n  contactsList: UserId[],\n  updates: Partial<{\n    seq: number,\n    pts: number,\n    date: number\n  }>,\n  filters: FiltersStorage['filters'],\n  maxSeenMsgId: number,\n  stateCreatedTime: number,\n  recentEmoji: string[],\n  topPeersCache: {\n    [type in TopPeerType]?: {\n      peers: MyTopPeer[],\n      cachedTime: number\n    }\n  },\n  recentSearch: PeerId[],\n  version: typeof STATE_VERSION,\n  build: typeof BUILD,\n  authState: AuthState,\n  hiddenPinnedMessages: {[peerId: PeerId]: number},\n  settings: {\n    messagesTextSize: number,\n    distanceUnit: 'kilometers' | 'miles',\n    sendShortcut: 'enter' | 'ctrlEnter',\n    animationsEnabled: boolean,\n    autoDownload: {\n      contacts?: boolean, // ! DEPRECATED\n      private?: boolean, // ! DEPRECATED\n      groups?: boolean, // ! DEPRECATED\n      channels?: boolean, // ! DEPRECATED\n      photo: AutoDownloadPeerTypeSettings,\n      video: AutoDownloadPeerTypeSettings,\n      file: AutoDownloadPeerTypeSettings\n    },\n    autoDownloadNew: AutoDownloadSettings,\n    autoPlay: {\n      gifs: boolean,\n      videos: boolean\n    },\n    stickers: {\n      suggest: boolean,\n      loop: boolean\n    },\n    emoji: {\n      suggest: boolean,\n      big: boolean\n    },\n    background?: Background, // ! DEPRECATED\n    themes: Theme[],\n    theme: Theme['name'],\n    notifications: {\n      sound: boolean\n    },\n    nightTheme?: boolean, // ! DEPRECATED\n    timeFormat: 'h12' | 'h23'\n  },\n  keepSigned: boolean,\n  chatContextMenuHintWasShown: boolean,\n  stateId: number,\n  notifySettings: {[k in Exclude<NotifyPeer['_'], 'notifyPeer'>]?: PeerNotifySettings.peerNotifySettings}\n};\n\nexport const STATE_INIT: State = {\n  allDialogsLoaded: {},\n  pinnedOrders: {},\n  contactsList: [],\n  updates: {},\n  filters: {},\n  maxSeenMsgId: 0,\n  stateCreatedTime: Date.now(),\n  recentEmoji: [],\n  topPeersCache: {},\n  recentSearch: [],\n  version: STATE_VERSION,\n  build: BUILD,\n  authState: {\n    _: IS_MOBILE ? 'authStateSignIn' : 'authStateSignQr'\n  },\n  hiddenPinnedMessages: {},\n  settings: {\n    messagesTextSize: 16,\n    distanceUnit: 'kilometers',\n    sendShortcut: 'enter',\n    animationsEnabled: true,\n    autoDownload: {\n      photo: {\n        contacts: true,\n        private: true,\n        groups: true,\n        channels: true\n      },\n      video: {\n        contacts: true,\n        private: true,\n        groups: true,\n        channels: true\n      },\n      file: {\n        contacts: true,\n        private: true,\n        groups: true,\n        channels: true\n      }\n    },\n    autoDownloadNew: {\n      _: 'autoDownloadSettings',\n      file_size_max: 3145728,\n      pFlags: {\n        video_preload_large: true,\n        audio_preload_next: true\n      },\n      photo_size_max: 1048576,\n      video_size_max: 15728640,\n      video_upload_maxbitrate: 100\n    },\n    autoPlay: {\n      gifs: true,\n      videos: true\n    },\n    stickers: {\n      suggest: true,\n      loop: true\n    },\n    emoji: {\n      suggest: true,\n      big: true\n    },\n    themes: [{\n      name: 'day',\n      background: {\n        blur: false,\n        slug: 'pattern',\n        color: '#dbddbb,#6ba587,#d5d88d,#88b884',\n        highlightningColor: 'hsla(86.4, 43.846153%, 45.117647%, .4)',\n        intensity: 50,\n        id: '1'\n      }\n    }, {\n      name: 'night',\n      background: {\n        blur: false,\n        slug: 'pattern',\n        // color: '#dbddbb,#6ba587,#d5d88d,#88b884',\n        color: '#fec496,#dd6cb9,#962fbf,#4f5bd5',\n        highlightningColor: 'hsla(299.142857, 44.166666%, 37.470588%, .4)',\n        intensity: -50,\n        id: '-1'\n      }\n    }],\n    theme: 'system',\n    notifications: {\n      sound: false\n    },\n    timeFormat: getTimeFormat()\n  },\n  keepSigned: true,\n  chatContextMenuHintWasShown: false,\n  stateId: nextRandomUint(32),\n  notifySettings: {}\n};\n\nconst ALL_KEYS = Object.keys(STATE_INIT) as any as Array<keyof State>;\n\nconst REFRESH_KEYS = ['contactsList', 'stateCreatedTime',\n  'maxSeenMsgId', 'filters', 'topPeers'] as any as Array<keyof State>;\n\nexport type StatePeerType = 'recentSearch' | 'topPeer' | 'dialog' | 'contact' | 'topMessage' | 'self';\n\n//const REFRESH_KEYS_WEEK = ['dialogs', 'allDialogsLoaded', 'updates', 'pinnedOrders'] as any as Array<keyof State>;\n\nexport class AppStateManager extends EventListenerBase<{\n  save: (state: State) => Promise<void>,\n  peerNeeded: (peerId: PeerId) => void,\n  peerUnneeded: (peerId: PeerId) => void\n}> {\n  public static STATE_INIT = STATE_INIT;\n  private loaded: Promise<State>;\n  private log = logger('STATE'/* , LogLevels.error */);\n\n  private state: State;\n\n  private neededPeers: Map<PeerId, Set<string>> = new Map();\n  private singlePeerMap: Map<string, PeerId> = new Map();\n\n  public storages = {\n    users: new AppStorage<Record<UserId, User>, typeof DATABASE_STATE>(DATABASE_STATE, 'users'),\n    chats: new AppStorage<Record<ChatId, Chat>, typeof DATABASE_STATE>(DATABASE_STATE, 'chats'),\n    dialogs: new AppStorage<Record<PeerId, Dialog>, typeof DATABASE_STATE>(DATABASE_STATE, 'dialogs')\n  };\n\n  public storagesResults: {\n    users: User[],\n    chats: Chat[],\n    dialogs: Dialog[]\n  } = {} as any;\n\n  public storage = stateStorage;\n\n  public newVersion: string;\n\n  constructor() {\n    super();\n    this.loadSavedState();\n\n    rootScope.addEventListener('user_auth', () => {\n      this.requestPeerSingle(rootScope.myId, 'self');\n    });\n  }\n\n  public loadSavedState(): Promise<State> {\n    if(this.loaded) return this.loaded;\n    console.time('load state');\n    this.loaded = new Promise((resolve) => {\n      const storagesKeys = Object.keys(this.storages) as Array<keyof AppStateManager['storages']>;\n      const storagesPromises: Promise<any>[] = storagesKeys.map(key => this.storages[key].getAll());\n\n      const promises/* : Promise<any>[] */ = ALL_KEYS.map(key => stateStorage.get(key))\n      .concat(sessionStorage.get('user_auth'), sessionStorage.get('state_id'))\n      .concat(stateStorage.get('user_auth')) // support old webk format\n      .concat(storagesPromises);\n\n      Promise.all(promises).then(async(arr) => {\n        // await new Promise((resolve) => setTimeout(resolve, 3e3));\n        /* const self = this;\n        const skipHandleKeys = new Set(['isProxy', 'filters', 'drafts']);\n        const getHandler = (path?: string) => {\n          return {\n            get(target: any, key: any) {\n              if(key === 'isProxy') {\n                return true;\n              }\n\n              const prop = target[key];\n\n              if(prop !== undefined && !skipHandleKeys.has(key) && !prop.isProxy && typeof(prop) === 'object') {\n                target[key] = new Proxy(prop, getHandler(path || key));\n                return target[key];\n              }\n              \n              return prop;\n            },\n            set(target: any, key: any, value: any) {\n              console.log('Setting', target, `.${key} to equal`, value, path);\n          \n              target[key] = value;\n\n              // @ts-ignore\n              self.pushToState(path || key, path ? self.state[path] : value, false);\n\n              return true;\n            }\n          };\n        }; */\n\n        let state: State = this.state = {} as any;\n\n        // ! then can't store false values\n        for(let i = 0, length = ALL_KEYS.length; i < length; ++i) {\n          const key = ALL_KEYS[i];\n          const value = arr[i];\n          if(value !== undefined) {\n            // @ts-ignore\n            state[key] = value;\n          } else {\n            this.pushToState(key, copy(STATE_INIT[key]));\n          }\n        }\n\n        arr.splice(0, ALL_KEYS.length);\n\n        // * Read auth\n        let auth = arr.shift() as UserAuth | number;\n        const stateId = arr.shift() as number;\n        const shiftedWebKAuth = arr.shift() as UserAuth | number;\n        if(!auth && shiftedWebKAuth) { // support old webk auth\n          auth = shiftedWebKAuth;\n          const keys: string[] = ['dc', 'server_time_offset', 'xt_instance'];\n          for(let i = 1; i <= 5; ++i) {\n            keys.push(`dc${i}_server_salt`);\n            keys.push(`dc${i}_auth_key`);\n          }\n\n          const values = await Promise.all(keys.map(key => stateStorage.get(key as any)));\n          keys.push('user_auth');\n          values.push(typeof(auth) === 'number' || typeof(auth) === 'string' ? {dcID: values[0] || App.baseDcId, date: Date.now() / 1000 | 0, id: auth.toPeerId(false)} as UserAuth : auth);\n\n          let obj: any = {};\n          keys.forEach((key, idx) => {\n            obj[key] = values[idx];\n          });\n\n          await sessionStorage.set(obj);\n        }\n        \n        /* if(!auth) { // try to read Webogram's session from localStorage\n          try {\n            const keys = Object.keys(localStorage);\n            for(let i = 0; i < keys.length; ++i) {\n              const key = keys[i];\n              let value: any;\n              try {\n                value = localStorage.getItem(key);\n                value = JSON.parse(value);\n              } catch(err) {\n                //console.error(err);\n              }\n\n              sessionStorage.set({\n                [key as any]: value\n              });\n            }\n\n            auth = sessionStorage.getFromCache('user_auth');\n          } catch(err) {\n            this.log.error('localStorage import error', err);\n          }\n        } */\n\n        if(auth) {\n          // ! Warning ! DON'T delete this\n          state.authState = {_: 'authStateSignedIn'};\n          rootScope.dispatchEvent('user_auth', typeof(auth) === 'number' || typeof(auth) === 'string' ? \n            {dcID: 0, date: Date.now() / 1000 | 0, id: auth.toPeerId(false)} : \n            auth); // * support old version\n        }\n\n        // * Read storages\n        for(let i = 0, length = storagesKeys.length; i < length; ++i) {\n          this.storagesResults[storagesKeys[i]] = arr[i] as any;\n        }\n\n        arr.splice(0, storagesKeys.length);\n\n        if(state.stateId !== stateId) {\n          if(stateId !== undefined) {\n            const preserve: Map<keyof State, State[keyof State]> = new Map([\n              ['authState', undefined],\n              ['stateId', undefined]\n            ]);\n  \n            preserve.forEach((_, key) => {\n              preserve.set(key, copy(state[key]));\n            });\n  \n            state = this.state = copy(STATE_INIT);\n  \n            preserve.forEach((value, key) => {\n              // @ts-ignore\n              state[key] = value;\n            });\n\n            for(const key in this.storagesResults) {\n              this.storagesResults[key as keyof AppStateManager['storagesResults']].length = 0;\n            }\n\n            this.storage.set(state);\n          }\n\n          await sessionStorage.set({\n            state_id: state.stateId\n          });\n        }\n\n        const time = Date.now();\n        if((state.stateCreatedTime + REFRESH_EVERY) < time) {\n          if(DEBUG) {\n            this.log('will refresh state', state.stateCreatedTime, time);\n          }\n\n          const r = (keys: typeof REFRESH_KEYS) => {\n            keys.forEach(key => {\n              this.pushToState(key, copy(STATE_INIT[key]));\n  \n              // @ts-ignore\n              const s = this.storagesResults[key];\n              if(s && s.length) {\n                s.length = 0;\n              }\n            });\n          };\n          \n          r(REFRESH_KEYS);\n\n          /* if((state.stateCreatedTime + REFRESH_EVERY_WEEK) < time) {\n            if(DEBUG) {\n              this.log('will refresh updates');\n            }\n\n            r(REFRESH_KEYS_WEEK);\n          } */\n        }\n        \n        //state = this.state = new Proxy(state, getHandler());\n\n        // * support old version\n        if(!state.settings.hasOwnProperty('theme') && state.settings.hasOwnProperty('nightTheme')) {\n          state.settings.theme = state.settings.nightTheme ? 'night' : 'day';\n          this.pushToState('settings', state.settings);\n        }\n\n        // * support old version\n        if(!state.settings.hasOwnProperty('themes') && state.settings.background) {\n          state.settings.themes = copy(STATE_INIT.settings.themes);\n          const theme = state.settings.themes.find(t => t.name === state.settings.theme);\n          if(theme) {\n            theme.background = state.settings.background;\n            this.pushToState('settings', state.settings);\n          }\n        }\n\n        // * migrate auto download settings\n        const autoDownloadSettings = state.settings.autoDownload;\n        if(autoDownloadSettings?.private !== undefined) {\n          const oldTypes = [\n            'contacts' as const, \n            'private' as const, \n            'groups' as const, \n            'channels' as const\n          ];\n\n          const mediaTypes = [\n            'photo' as const,\n            'video' as const,\n            'file' as const\n          ];\n\n          mediaTypes.forEach(mediaType => {\n            const peerTypeSettings: AutoDownloadPeerTypeSettings = autoDownloadSettings[mediaType] = {} as any;\n            oldTypes.forEach(peerType => {\n              peerTypeSettings[peerType] = autoDownloadSettings[peerType];\n            });\n          });\n\n          oldTypes.forEach(peerType => {\n            delete autoDownloadSettings[peerType];\n          });\n\n          this.pushToState('settings', state.settings);\n        }\n\n        validateInitObject(STATE_INIT, state, (missingKey) => {\n          // @ts-ignore\n          this.pushToState(missingKey, state[missingKey]);\n        });\n\n        if(state.version !== STATE_VERSION || state.build !== BUILD/*  || true */) {\n          // reset filters and dialogs if version is older\n          if(compareVersion(state.version, '0.8.7') === -1) {\n            this.state.allDialogsLoaded = copy(STATE_INIT.allDialogsLoaded);\n            this.state.filters = copy(STATE_INIT.filters);\n            const result = this.storagesResults.dialogs;\n            if(result?.length) {\n              result.length = 0;\n            }\n          }\n\n          // * migrate backgrounds (March 13, 2022; to version 1.3.0)\n          if(compareVersion(state.version, '1.3.0') === -1) {\n            let migrated = false;\n            state.settings.themes.forEach((theme, idx, arr) => {\n              if((\n                theme.name === 'day' && \n                theme.background.slug === 'ByxGo2lrMFAIAAAAmkJxZabh8eM' && \n                theme.background.type === 'image' \n              ) || (\n                theme.name === 'night' && \n                theme.background.color === '#0f0f0f' && \n                theme.background.type === 'color' \n              )) {\n                const newTheme = STATE_INIT.settings.themes.find(newTheme => newTheme.name === theme.name);\n                if(newTheme) {\n                  arr[idx] = copy(newTheme);\n                  migrated = true;\n                }\n              }\n            });\n\n            if(migrated) {\n              this.pushToState('settings', state.settings);\n            }\n          }\n          \n          if(compareVersion(state.version, STATE_VERSION) !== 0) {\n            this.newVersion = STATE_VERSION;\n          }\n\n          this.pushToState('version', STATE_VERSION);\n          this.pushToState('build', BUILD);\n        }\n\n        // ! probably there is better place for it\n        rootScope.settings = state.settings;\n\n        if(DEBUG) {\n          this.log('state res', state, copy(state));\n        }\n        \n        //return resolve();\n\n        console.timeEnd('load state');\n        resolve(state);\n      }).catch(resolve);\n    });\n\n    return this.loaded;\n  }\n\n  public getState() {\n    return this.state === undefined ? this.loadSavedState() : Promise.resolve(this.state);\n  }\n\n  public setByKey(key: string, value: any) {\n    setDeepProperty(this.state, key, value);\n    rootScope.dispatchEvent('settings_updated', {key, value});\n\n    const first = key.split('.')[0];\n    // @ts-ignore\n    this.pushToState(first, this.state[first]);\n  }\n\n  public pushToState<T extends keyof State>(key: T, value: State[T], direct = true) {\n    if(direct) {\n      this.state[key] = value;\n    }\n\n    this.setKeyValueToStorage(key, value);\n  }\n\n  public setKeyValueToStorage<T extends keyof State>(key: T, value: State[T] = this.state[key]) {\n    this.storage.set({\n      [key]: value\n    });\n  }\n\n  public requestPeer(peerId: PeerId, type: StatePeerType, limit?: number) {\n    let set = this.neededPeers.get(peerId);\n    if(set && set.has(type)) {\n      return;\n    }\n\n    if(!set) {\n      set = new Set();\n      this.neededPeers.set(peerId, set);\n    }\n\n    set.add(type);\n\n    this.dispatchEvent('peerNeeded', peerId);\n\n    if(limit !== undefined) {\n      this.keepPeerSingle(peerId, type);\n    }\n  }\n\n  public requestPeerSingle(peerId: PeerId, type: StatePeerType, keepPeerIdSingle: PeerId = peerId) {\n    return this.requestPeer(peerId, type + '_' + keepPeerIdSingle as any, 1);\n  }\n\n  public releaseSinglePeer(peerId: PeerId, type: StatePeerType) {\n    return this.keepPeerSingle(NULL_PEER_ID, type + '_' + peerId as any);\n  }\n\n  public isPeerNeeded(peerId: PeerId) {\n    return this.neededPeers.has(peerId);\n  }\n\n  public keepPeerSingle(peerId: PeerId, type: StatePeerType) {\n    const existsPeerId = this.singlePeerMap.get(type);\n    if(existsPeerId && existsPeerId !== peerId && this.neededPeers.has(existsPeerId)) {\n      const set = this.neededPeers.get(existsPeerId);\n      set.delete(type);\n\n      if(!set.size) {\n        this.neededPeers.delete(existsPeerId);\n        this.dispatchEvent('peerUnneeded', existsPeerId);\n      }\n    }\n\n    if(peerId) {\n      this.singlePeerMap.set(type, peerId);\n    } else {\n      this.singlePeerMap.delete(type);\n    }\n  }\n\n  /* public resetState() {\n    for(let i in this.state) {\n      // @ts-ignore\n      this.state[i] = false;\n    }\n    sessionStorage.set(this.state).then(() => {\n      location.reload();\n    });\n  } */\n}\n\n//console.trace('appStateManager include');\n\nconst appStateManager = new AppStateManager();\nMOUNT_CLASS_TO.appStateManager = appStateManager;\nexport default appStateManager;\n","export default function getTimeFormat(): 'h12' | 'h23' {\n  // try {\n  //   const resolvedOptions = Intl.DateTimeFormat(navigator.language,  {hour: 'numeric'}).resolvedOptions();\n  //   if('hourCycle' in resolvedOptions) {\n  //     return (resolvedOptions as any).hourCycle === 'h12' ? 'h12' : 'h23';\n  //   } else {\n  //     return resolvedOptions.hour12 ? 'h12' : 'h23';\n  //   }\n  // } catch(err) {\n    return new Date().toLocaleString().match(/\\s(AM|PM)/) ? 'h12' : 'h23';\n  // }\n}\n","import getDeepProperty from \"./getDeepProperty\";\n\nexport default function setDeepProperty(object: any, key: string, value: any) {\n  const splitted = key.split('.');\n  getDeepProperty(object, splitted.slice(0, -1).join('.'))[splitted.pop()] = value;\n}\n"],"sourceRoot":""}