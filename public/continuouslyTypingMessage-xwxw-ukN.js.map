{"version":3,"file":"continuouslyTypingMessage-xwxw-ukN.js","sources":["../src/components/chat/bubbleParts/continuouslyTypingMessage.ts"],"sourcesContent":["import {animate} from '@helpers/animation';\nimport styles from '@components/chat/bubbleParts/continuouslyTypingMessage.module.scss';\n\n\ntype WrapContinuouslyTypingMessageArgs = {\n  root: Node;\n  bubble: HTMLElement;\n  scrollable: HTMLElement;\n  isEnd?: boolean;\n  prevPosition?: number;\n};\n\ntype Result = {\n  allNodes: Node[];\n  bubble: HTMLElement;\n  clean: () => void;\n  currentPosition: number;\n  currentNodeIdx: number;\n  nextIsEnd?: boolean;\n};\n\nexport function wrapContinuouslyTypingMessage({root, bubble, scrollable, isEnd = false, prevPosition = -1}: WrapContinuouslyTypingMessageArgs): Result {\n  const {\n    maxPosition,\n    nodeContents,\n    allNodes,\n    currentNodeIdx\n  } = processNodeTree({root, prevPosition});\n\n  let\n    lastTextNode: Node,\n    cleaned = false,\n    ended = false\n  ;\n\n  function clean() {\n    cleaned = true;\n    allNodes.forEach(node => nodeContents.delete(node));\n  };\n\n  function onEnd() {\n    if(ended) return;\n    ended = true;\n\n    if(!isEnd) appendDots(lastTextNode);\n  }\n\n  const result = {\n    allNodes,\n    bubble,\n    clean,\n    currentPosition: prevPosition,\n    currentNodeIdx,\n    nextIsEnd: isEnd\n  };\n\n  runAnimation({\n    scrollable,\n    typeNext: (length) => typeNext({\n      result,\n      setLastTextNode: (node) => lastTextNode = node,\n      nodeContents,\n      onEnd,\n      length\n    }),\n    isCleaned: () => cleaned,\n    maxPosition,\n    prevPosition\n  });\n\n  return result;\n}\n\n\ntype ProcessNodeTreeArgs = {\n  root: Node;\n  prevPosition: number;\n};\n\nfunction processNodeTree({root, prevPosition}: ProcessNodeTreeArgs) {\n  const treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_ALL);\n\n  const allNodes: Node[] = [];\n  const nodeContents = new WeakMap<Node, string>();\n\n  while(treeWalker.nextNode()) allNodes.push(treeWalker.currentNode);\n\n  let\n    position = -1,\n    currentNodeIdx = 0\n  ;\n\n  for(const node of allNodes) {\n    if(node.nodeType === Node.TEXT_NODE) {\n      nodeContents.set(node, node.textContent);\n\n      node.textContent = node.textContent.slice(0, Math.max(0, prevPosition - position + 1));\n\n      position += nodeContents.get(node).length;\n    } else if(node instanceof Element && position > prevPosition) {\n      node.classList.add(styles.hidden);\n    }\n\n    if(position <= prevPosition) {\n      currentNodeIdx++;\n    }\n  }\n\n  return {maxPosition: position, nodeContents, allNodes, currentNodeIdx};\n}\n\n\nfunction appendDots(node: Node) {\n  const parent = node.parentNode;\n  if(!(parent instanceof Element)) return;\n\n  const dots = document.createElement('span');\n  dots.className = styles.Dots;\n  dots.textContent = ' ';\n\n  new Array(3).fill(null).forEach((_, idx) => {\n    const dot = document.createElement('span');\n    dot.textContent = '.';\n    dot.classList.add(styles.Dot, styles['Dot' + (idx + 1)]);\n    dots.appendChild(dot);\n  });\n\n  parent.appendChild(dots);\n}\n\n\ntype TypeNextArgs = {\n  result: Result;\n  setLastTextNode: (node: Node) => void;\n  onEnd: () => void;\n  nodeContents: WeakMap<Node, string>;\n  length: number;\n};\n\nfunction typeNext({result, setLastTextNode, onEnd, nodeContents, length}: TypeNextArgs) {\n  const {allNodes, clean} = result;\n\n  while(result.currentNodeIdx < allNodes.length && length) {\n    const node = allNodes[result.currentNodeIdx];\n\n    if(node instanceof Element) {\n      result.currentNodeIdx++;\n      node.classList.remove(styles.hidden);\n    } else if(node.nodeType === Node.TEXT_NODE) {\n      const typedLength = node.textContent.length;\n      const finalContent = nodeContents.get(node);\n\n      const leftOverLength = Math.max(0, typedLength + length - finalContent.length);\n\n      const start = typedLength;\n      const end = start + length - leftOverLength;\n\n      node.textContent += finalContent.slice(start, end);\n\n      length = leftOverLength;\n      result.currentPosition += end - start;\n\n      if(leftOverLength) result.currentNodeIdx++;\n      setLastTextNode(node);\n    }\n  }\n\n  if(result.currentNodeIdx >= allNodes.length) {\n    clean();\n    onEnd();\n  }\n}\n\n\nconst BASE_DELAY = 60 * 1_000 / (800 * 5); // 800wpm\nconst MIN_DELAY = 60 * 1_000 / (2_400 * 5); // 2_400wpm\nconst DELAY_VARIATION = 0.3;\n\n// Try to write it with the base speed of 800wpm or burst it in 5 seconds if it's a long message, maximum speed of 2_400wpm overall\nfunction getRandomDelay(targetDelay: number) {\n  const delay = Math.max(MIN_DELAY, Math.min(BASE_DELAY, targetDelay));\n  return delay + Math.random() * delay * DELAY_VARIATION;\n}\n\n\ntype RunAnimationArgs = {\n  scrollable: HTMLElement;\n  typeNext: (length: number) => void;\n  isCleaned: () => boolean;\n  maxPosition: number;\n  prevPosition: number;\n};\n\nconst TARGET_TIME_TO_WRITE = 5000;\n\nfunction runAnimation({scrollable, typeNext, isCleaned, maxPosition, prevPosition}: RunAnimationArgs) {\n  const targetDelay = TARGET_TIME_TO_WRITE / (maxPosition - prevPosition);\n\n  let prevTime = 0;\n\n  const animationInvalidation = registerAnimationInvalidation(scrollable);\n\n  const checkCleaned = () => {\n    if(!isCleaned()) return false;\n\n    animationInvalidation.cleanup();\n\n    return true;\n  };\n\n  let skip = -1;\n  const skipFrames = 2;\n\n  animate(() => {\n    if(checkCleaned()) return false;\n\n    skip = (skip + 1) % skipFrames;\n    if(skip) return true;\n\n    const now = performance.now();\n    if(!prevTime) prevTime = now;\n\n    const length = Math.max(0, Math.round((now - prevTime) / getRandomDelay(targetDelay)));\n\n    if(length) {\n      typeNext(length);\n      prevTime = now;\n    }\n\n    if(length && !animationInvalidation.isInvalidated()) {\n      // value.aboutToScroll = true;\n\n      // animate(() => {\n      // value.aboutToScroll = false;\n      // if(value.invalidateTimeoutId || checkCleaned()) return;\n\n      const threshold = 120; // px\n      if(scrollable.scrollTop + scrollable.clientHeight > scrollable.scrollHeight - threshold) {\n        scrollable.scrollTop = scrollable.scrollHeight;\n      }\n      // });\n    }\n\n    return true;\n  });\n}\n\n\ntype RegisteredScrollableValue = {\n  count: number;\n  invalidateTimeoutId?: number;\n  // aboutToScroll?: boolean;\n  cleanup: () => void;\n};\n\nconst INVALIDATE_SCROLL_TIMEOUT = 450;\n\nconst events = ['wheel', 'touchstart', 'pointerdown', 'keydown'] as const;\nconst registeredScrollables = new Map<HTMLElement, RegisteredScrollableValue>();\n\nfunction registerAnimationInvalidation(scrollable: HTMLElement) {\n  let value: RegisteredScrollableValue;\n\n  if(!registeredScrollables.has(scrollable)) {\n    value = {\n      count: 0,\n      cleanup: () => {\n        events.forEach(event => {\n          scrollable.removeEventListener(event, callback);\n        });\n      }\n    };\n\n    const callback = () => {\n      if(value.invalidateTimeoutId) self.clearTimeout(value.invalidateTimeoutId);\n      value.invalidateTimeoutId = self.setTimeout(() => {\n        value.invalidateTimeoutId = undefined;\n      }, INVALIDATE_SCROLL_TIMEOUT)\n    };\n\n    events.forEach(event => {\n      scrollable.addEventListener(event, callback, {passive: true});\n    });\n\n    registeredScrollables.set(scrollable, value);\n  } else {\n    value = registeredScrollables.get(scrollable);\n  }\n\n  value.count++;\n\n  let cleaned = false;\n\n  return {\n    isInvalidated: () => !!value.invalidateTimeoutId,\n    cleanup: () => {\n      if(cleaned) return;\n      cleaned = true;\n\n      value.count--;\n\n      if(value.count <= 0) {\n        value.cleanup();\n        registeredScrollables.delete(scrollable);\n      }\n    }\n  };\n}\n"],"names":["wrapContinuouslyTypingMessage","root","bubble","scrollable","isEnd","prevPosition","maxPosition","nodeContents","allNodes","currentNodeIdx","processNodeTree","lastTextNode","cleaned","ended","clean","node","onEnd","appendDots","result","runAnimation","length","typeNext","treeWalker","position","styles","parent","dots","_","idx","dot","setLastTextNode","typedLength","finalContent","leftOverLength","start","end","BASE_DELAY","MIN_DELAY","DELAY_VARIATION","getRandomDelay","targetDelay","delay","TARGET_TIME_TO_WRITE","isCleaned","prevTime","animationInvalidation","registerAnimationInvalidation","checkCleaned","skip","skipFrames","animate","now","INVALIDATE_SCROLL_TIMEOUT","events","registeredScrollables","value","event","callback"],"mappings":"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"}