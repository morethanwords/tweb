{"version":3,"file":"shaderSources-BxWAu5ue.js","sources":["../src/components/mediaEditor/webgl/shaderSources.ts"],"sourcesContent":["export const vertexShaderSource = `\nprecision highp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform float uAngle;\nuniform float uScale;\nuniform vec2 uFlip;\nuniform vec2 uImageSize;\nuniform vec2 uResolution;\nuniform vec2 uTranslation;\n\nvarying highp vec2 vTextureCoord;\n\nvoid main(void) {\n  vec2 position = aVertexPosition;\n  // Center to 0,0\n  position = position - uImageSize / 2.0;\n  // Flip\n  position = position * uFlip;\n  // Scale\n  position *= uScale;\n\n  // Rotate\n  vec2 rotation = vec2(sin(uAngle), cos(uAngle));\n  position = vec2(\n    position.x * rotation.y + position.y * rotation.x,\n    position.y * rotation.y - position.x * rotation.x\n  );\n\n  // Go to canvas center\n  position += uResolution / 2.0;\n\n  // Translate and normalize\n  position = ((position + uTranslation) / uResolution) * 2.0 - 1.0;  \n\n  gl_Position = vec4(position * vec2(1, -1), 0.0, 1.0);\n  vTextureCoord = aTextureCoord;\n}\n`;\n\nexport const fragmentShaderSource = `\nprecision highp float;\n\nvarying highp vec2 vTextureCoord;\n\nuniform vec2 uImageSize;\n\nuniform sampler2D uSampler;\n\nuniform vec2 uResolution;\n\nuniform float uEnhance;\nuniform float uSaturation;\nuniform float uBrightness;\nuniform float uContrast;\nuniform float uWarmth;\nuniform float uFade;\nuniform float uShadows;\nuniform float uHighlights;\nuniform float uVignette;\nuniform float uGrain;\nuniform float uSharpen;\n\n\n// Constants\n\nvec3 hsLuminanceWeighting = vec3(0.3, 0.3, 0.3);\n// https://www.w3.org/TR/WCAG21/#dfn-relative-luminance\nconst vec3 luminosityFactor = vec3(0.2126, 0.7152, 0.0722);\n\nconst lowp float permTexUnit = 1.0 / 256.0;\nconst lowp float permTexUnitHalf = 0.5 / 256.0;\nconst lowp float grainsize = 2.3;\n\n\n// Utils\n\nhighp vec3 rgbToYuv(vec3 rgb){\n    highp float y = 0.299*rgb.r + 0.587*rgb.g + 0.114*rgb.b;\n    return vec3(y, 0.493*(rgb.b-y), 0.877*(rgb.r-y));\n}\n\nhighp vec3 yuvToRgb(vec3 yuv){\n    highp float y = yuv.x;\n    highp float u = yuv.y;\n    highp float v = yuv.z;\n    \n    highp vec3 r = vec3(\n        y + 1.0/0.877*v,\n        y - 0.39393*u - 0.58081*v,\n        y + 1.0/0.493*u\n    );\n    return r;\n}\n\nfloat colorLuminosity(vec3 color) {\n  return dot(color, luminosityFactor);\n}\n\nfloat easeInOutSigmoid(float x, float k) {\n  x = clamp(x, 0.0, 1.0);\n  float sigmoid = 1.0 / (1.0 + exp(-k * (x - 0.5)));\n  return sigmoid;\n}\n\nhighp vec4 rnm(in highp vec2 tc) {\n  highp float noise = sin(dot(tc,vec2(12.9898,78.233))) * 43758.5453;\n  \n  highp float noiseR = fract(noise)*2.0-1.0;\n  highp float noiseG = fract(noise*1.2154)*2.0-1.0;\n  highp float noiseB = fract(noise*1.3453)*2.0-1.0;\n  highp float noiseA = fract(noise*1.3647)*2.0-1.0;\n  \n  return vec4(noiseR,noiseG,noiseB,noiseA);\n}\n\nhighp float fade(in highp float t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nhighp float pnoise3D(in highp vec3 p) {\n  highp vec3 pi = permTexUnit*floor(p)+permTexUnitHalf;\n  highp vec3 pf = fract(p);\n  \n  // Noise contributions from (x=0, y=0), z=0 and z=1\n  highp float perm00 = rnm(pi.xy).a ;\n  highp vec3  grad000 = rnm(vec2(perm00, pi.z)).rgb * 4.0 - 1.0;\n  highp float n000 = dot(grad000, pf);\n  highp vec3  grad001 = rnm(vec2(perm00, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\n  highp float n001 = dot(grad001, pf - vec3(0.0, 0.0, 1.0));\n  \n  // Noise contributions from (x=0, y=1), z=0 and z=1\n  highp float perm01 = rnm(pi.xy + vec2(0.0, permTexUnit)).a ;\n  highp vec3  grad010 = rnm(vec2(perm01, pi.z)).rgb * 4.0 - 1.0;\n  highp float n010 = dot(grad010, pf - vec3(0.0, 1.0, 0.0));\n  highp vec3  grad011 = rnm(vec2(perm01, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\n  highp float n011 = dot(grad011, pf - vec3(0.0, 1.0, 1.0));\n  \n  // Noise contributions from (x=1, y=0), z=0 and z=1\n  highp float perm10 = rnm(pi.xy + vec2(permTexUnit, 0.0)).a ;\n  highp vec3  grad100 = rnm(vec2(perm10, pi.z)).rgb * 4.0 - 1.0;\n  highp float n100 = dot(grad100, pf - vec3(1.0, 0.0, 0.0));\n  highp vec3  grad101 = rnm(vec2(perm10, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\n  highp float n101 = dot(grad101, pf - vec3(1.0, 0.0, 1.0));\n  \n  // Noise contributions from (x=1, y=1), z=0 and z=1\n  highp float perm11 = rnm(pi.xy + vec2(permTexUnit, permTexUnit)).a ;\n  highp vec3  grad110 = rnm(vec2(perm11, pi.z)).rgb * 4.0 - 1.0;\n  highp float n110 = dot(grad110, pf - vec3(1.0, 1.0, 0.0));\n  highp vec3  grad111 = rnm(vec2(perm11, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\n  highp float n111 = dot(grad111, pf - vec3(1.0, 1.0, 1.0));\n  \n  // Blend contributions along x\n  highp vec4 n_x = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(pf.x));\n  \n  // Blend contributions along y\n  highp vec2 n_xy = mix(n_x.xy, n_x.zw, fade(pf.y));\n  \n  // Blend contributions along z\n  highp float n_xyz = mix(n_xy.x, n_xy.y, fade(pf.z));\n  \n  return n_xyz;\n}\n\nlowp vec2 coordRot(in lowp vec2 tc, in lowp float angle) {\n  lowp float rotX = ((tc.x * 2.0 - 1.0) * cos(angle)) - ((tc.y * 2.0 - 1.0) * sin(angle));\n  lowp float rotY = ((tc.y * 2.0 - 1.0) * cos(angle)) + ((tc.x * 2.0 - 1.0) * sin(angle));\n  rotX = rotX * 0.5 + 0.5;\n  rotY = rotY * 0.5 + 0.5;\n  return vec2(rotX,rotY);\n}\n\n\n\n// Adjustments\n\nvec4 brightness(vec4 color, float value) {\n  float mag = value * 1.045;\n  float exppower = 1.0 + abs(mag);\n\n  if (mag < 0.0) {\n    exppower = 1.0 / exppower;\n  }\n\n  color.r = 1.0 - pow((1.0 - color.r), exppower);\n  color.g = 1.0 - pow((1.0 - color.g), exppower);\n  color.b = 1.0 - pow((1.0 - color.b), exppower);\n  return color;\n}\n\nvec4 contrast(vec4 color, float value) {\n  value *= .3;\n  return vec4(clamp(0.5 + (1.0 + value) * (color.rgb - 0.5), 0.0, 1.0), color.a);\n}\n\nvec4 saturation(vec4 color, float value) {\n  vec3 grayscale = vec3(colorLuminosity(color.rgb));\n  return vec4(mix(grayscale, color.rgb, 1.0 + value), color.a);\n}\n\nvec4 warmth(vec4 color, float value) {\n  highp vec3 yuvVec;\n\n  if(value > 0.0) {\n      yuvVec = vec3(0.1765, -0.1255, 0.0902);\n  }\n  else {\n      yuvVec = -vec3(0.0588,  0.1569, -0.1255);\n  }\n  highp vec3 yuvColor = rgbToYuv(color.rgb);\n  highp float luma = yuvColor.r;\n  highp float curveScale = sin(luma * 3.14159);\n  yuvColor += 0.375 * value * curveScale * yuvVec;\n\n  return vec4(clamp(yuvToRgb(yuvColor), 0.0, 1.0), color.a);\n}\n\nvec4 fade(vec4 color, float value) {\n  highp vec3 co1 = vec3(-0.9772);\n  highp vec3 co2 = vec3(1.708);\n  highp vec3 co3 = vec3(-0.1603);\n  highp vec3 co4 = vec3(0.2878);\n  \n  highp vec3 comp1 = co1 * pow(color.rgb, vec3(3.0));\n  highp vec3 comp2 = co2 * pow(color.rgb, vec3(2.0));\n  highp vec3 comp3 = co3 * color.rgb;\n  highp vec3 comp4 = co4;\n  \n  highp vec3 finalComponent = comp1 + comp2 + comp3 + comp4;\n  highp vec3 difference = finalComponent - color.rgb;\n  highp vec3 scalingValue = vec3(0.9);\n  \n  highp vec3 faded = color.rgb + (difference * scalingValue);\n  \n  return vec4((color.rgb * (1.0 - value)) + (faded * value), color.a);\n}\n\nvec4 highlights(vec4 color, float highlights, float shadows) {\n  mediump float hsLuminance = dot(color.rgb, hsLuminanceWeighting);\n\n  mediump float shadow = clamp((pow(hsLuminance, 1.0 / shadows) + (-0.76) * pow(hsLuminance, 2.0 / shadows)) - hsLuminance, 0.0, 1.0);\n  mediump float highlight = clamp((1.0 - (pow(1.0 - hsLuminance, 1.0 / (2.0 - highlights)) + (-0.8) * pow(1.0 - hsLuminance, 2.0 / (2.0 - highlights)))) - hsLuminance, -1.0, 0.0);\n  lowp vec3 hsresult = vec3(0.0, 0.0, 0.0) + ((hsLuminance + shadow + highlight) - 0.0) * ((color.rgb - vec3(0.0, 0.0, 0.0)) / (hsLuminance - 0.0));\n  \n  mediump float contrastedLuminance = ((hsLuminance - 0.5) * 1.5) + 0.5;\n  mediump float whiteInterp = contrastedLuminance * contrastedLuminance * contrastedLuminance;\n  mediump float whiteTarget = clamp(highlights, 1.0, 2.0) - 1.0;\n  hsresult = mix(hsresult, vec3(1.0), clamp(whiteInterp * whiteTarget, 0.0, 1.0));\n\n  mediump float invContrastedLuminance = 1.0 - contrastedLuminance;\n  mediump float blackInterp = invContrastedLuminance * invContrastedLuminance * invContrastedLuminance;\n  mediump float blackTarget = 1.0 - clamp(shadows, 0.0, 1.0);\n  hsresult = mix(hsresult, vec3(0.0), clamp(blackInterp * blackTarget, 0.0, 1.0));\n\n  return vec4(hsresult.rgb, color.a);\n}\n\nvec4 vignette(vec4 color, float value) {\n  vec2 coord = vTextureCoord.xy;\n\n  const lowp float midpoint = 0.7;\n  const lowp float fuzziness = 0.62;\n  \n  lowp float radDist = length(coord - 0.5) / sqrt(0.5);\n  lowp float mag = easeInOutSigmoid(radDist * midpoint, fuzziness) * value * 0.645;\n  color.rgb = mix(pow(color.rgb, vec3(1.0 / (1.0 - mag))), vec3(0.0), mag * mag);\n  return color;\n}\n\nvec4 grain(vec4 color, float value) {\n  if(value < 0.001) return color;\n  vec2 coord = vTextureCoord.xy;\n\n  highp vec3 rotOffset = vec3(1.425, 3.892, 5.835);\n  highp vec2 rotCoordsR = coordRot(coord, rotOffset.x);\n  highp vec3 noise = vec3(pnoise3D(vec3(rotCoordsR * vec2(uImageSize.x / grainsize, uImageSize.y / grainsize),0.0)));\n  \n  lowp vec3 lumcoeff = vec3(0.299,0.587,0.114);\n  lowp float luminance = dot(color.rgb, lumcoeff);\n  lowp float lum = smoothstep(0.2, 0.0, luminance);\n  lum += luminance;\n  \n  noise = mix(noise,vec3(0.0),pow(lum,4.0));\n  color.rgb = color.rgb + noise * value;\n  return color;\n}\n\nvec4 sharpen(float value) {\n  vec2 coord = vTextureCoord.xy;\n\n  vec2 step = 1.0 / uResolution.xy;\n\n  vec3 texA = texture2D( uSampler, coord + vec2(-step.x, -step.y) * 1.5 ).rgb;\n  vec3 texB = texture2D( uSampler, coord + vec2( step.x, -step.y) * 1.5 ).rgb;\n  vec3 texC = texture2D( uSampler, coord + vec2(-step.x,  step.y) * 1.5 ).rgb;\n  vec3 texD = texture2D( uSampler, coord + vec2( step.x,  step.y) * 1.5 ).rgb;\n\n  vec3 around = value * (texA + texB + texC + texD);\n  vec4 center = texture2D(uSampler, coord);\n\n  float centerMultiplier = 1.0 + 4.0 * value;\n\n  return vec4(clamp(center.rgb * centerMultiplier - around, 0.0, 1.0), center.a);\n}\n\n\n\nvoid main(void) {\n  vec4 color = texture2D(uSampler, vTextureCoord);\n\n  color = sharpen(uSharpen * 0.45 + uEnhance * .15);\n  color = grain(color, uGrain * 0.04);\n  color = saturation(color, uSaturation + uEnhance * .2);\n  color = warmth(color, uWarmth);\n  color = fade(color, uFade);\n  \n  color = highlights(color, (uHighlights + uEnhance * 0.15) * 0.75 + 1.0, (uShadows - uEnhance * 0.075) * 0.55 + 1.0);\n  color = contrast(color, uContrast + uEnhance * 0.1);\n\n  color = brightness(color, uBrightness + uEnhance * .25);\n  color = vignette(color, uVignette);\n\n  gl_FragColor = color;\n}\n`;\n"],"names":["vertexShaderSource","fragmentShaderSource"],"mappings":"AAAO,MAAMA,EAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0CrBC,EAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}