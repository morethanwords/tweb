{"version":3,"file":"437.e3c1b82898e079a73d1f.bundle.js","mappings":"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","sources":["webpack://tweb/./src/config/debug.ts","webpack://tweb/./src/config/modes.ts","webpack://tweb/./src/environment/ctx.ts","webpack://tweb/./src/helpers/array/findAndSplice.ts","webpack://tweb/./src/helpers/array/indexOfAndSplice.ts","webpack://tweb/./src/helpers/dT.ts","webpack://tweb/./src/helpers/eventListenerBase.ts","webpack://tweb/./src/helpers/makeError.ts","webpack://tweb/./src/lib/mtproto/superMessagePort.ts"],"sourcesContent":["/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport Modes from './modes';\r\n\r\nexport const DEBUG = (process.env.NODE_ENV !== 'production' || Modes.debug)/*  && false */;\r\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\r\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\r\nexport default DEBUG;\r\n\r\n// let m = DEBUG;\r\n/* if(!DEBUG) {\r\n  ctx.sandpitTurtle = () => {\r\n    //if(!m) {\r\n      for(let i in MOUNT_CLASS_TO) {\r\n        ctx[i] = MOUNT_CLASS_TO[i];\r\n      }\r\n      //m = true;\r\n    //}\r\n\r\n    //DEBUG = !DEBUG;\r\n  };\r\n} */\r\n\r\n/* export const superDebug = (object: any, key: string) => {\r\n  var d = object[key];\r\n  var beforeStr = '', afterStr = '';\r\n  for(var r of d) {\r\n    beforeStr += r.before.hex + '\\n';\r\n    afterStr += r.after.hex + '\\n';\r\n  }\r\n\r\n  beforeStr = beforeStr.trim();\r\n  afterStr = afterStr.trim();\r\n  //var beforeStr = d.map((r) => r.before.hex).join('\\n');\r\n  //var afterStr = d.map((r) => r.after.hex).join('\\n');\r\n\r\n  var dada = (name: string, str: string) => {\r\n    var a = document.createElement('a');\r\n    a.target = '_blank';\r\n    a.download = name + '.txt';\r\n    a.href = URL.createObjectURL(new Blob([str], {\r\n      type: 'text/plain'\r\n    }));\r\n    document.body.append(a);\r\n    a.click();\r\n  };\r\n\r\n  dada(key + '_' + 'before', beforeStr);\r\n  dada(key + '_' + 'after', afterStr);\r\n}\r\n\r\nMOUNT_CLASS_TO.superDebug = superDebug; */\r\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport type {TransportType} from '../lib/mtproto/dcConfigurator';\n\nconst Modes = {\n  test: location.search.indexOf('test=1') > 0/*  || true */,\n  debug: location.search.indexOf('debug=1') > 0,\n  http: false,\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\n  multipleConnections: true,\n  asServiceWorker: false,\n  transport: 'websocket' as TransportType\n};\n\n                       \nModes.http = location.search.indexOf('http=1') > 0;\n         \n\n                                      \n                  \n         \n\nif(Modes.http) {\n  Modes.transport = 'https';\n}\n\n                 \n                             \n         \n\nexport default Modes;\n","const ctx = typeof(window) !== 'undefined' ? window : self;\n\nexport default ctx;\n","export default function findAndSplice<T>(array: Array<T>, verify: (value: T, index?: number, array?: Array<T>) => boolean) {\n  const index = array.findIndex(verify);\n  return index !== -1 ? array.splice(index, 1)[0] : undefined;\n};\n","export default function indexOfAndSplice<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  const spliced = idx !== -1 && array.splice(idx, 1);\n  return spliced && spliced[0];\n}\n","const _logTimer = Date.now();\r\nexport default function dT() {\r\n  return '[' + ((Date.now() - _logTimer) / 1000).toFixed(3) + ']';\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// import { MOUNT_CLASS_TO } from \"../config/debug\";\r\nimport type {ArgumentTypes, SuperReturnType} from '../types';\r\nimport findAndSplice from './array/findAndSplice';\r\n\r\n// class EventSystem {\r\n//   wm: WeakMap<any, Record<any, Set<any>>> = new WeakMap();\r\n\r\n//   add(target: any, event: any, listener: any) {\r\n//     let listeners = this.wm.get(target);\r\n//     if (listeners === undefined) {\r\n//         listeners = {};\r\n//     }\r\n//     let listenersForEvent = listeners[event];\r\n//     if (listenersForEvent === undefined) {\r\n//         listenersForEvent = new Set();\r\n//     }\r\n//     listenersForEvent.add(listener);\r\n//     listeners[event] = listenersForEvent;\r\n//     //target.addEventListener(event, listener);\r\n//     this.wm.set(target, listeners);\r\n//   };\r\n\r\n//   remove(target: any, event: any, listener: any) {\r\n//     let listeners = this.wm.get(target);\r\n//     if (!listeners) return;\r\n//     let listenersForEvent = listeners[event];\r\n//     if (!listenersForEvent) return;\r\n//     listenersForEvent.delete(listener);\r\n//   };\r\n\r\n//   /* fire(target, event) {\r\n//      let listeners = this.wm.get(target);\r\n//      if (!listeners) return;\r\n//      let listenersForEvent = listeners[event];\r\n//      if (!listenersForEvent) return;\r\n//      for (let handler of handlers) {\r\n//          setTimeout(handler, 0, event, target); // we use a setTimeout here because we want event triggering to be asynchronous.\r\n//      }\r\n//   }; */\r\n// }\r\n\r\n// console.log = () => {};\r\n\r\n// const e = new EventSystem();\r\n// MOUNT_CLASS_TO.e = e;\r\n\r\nexport type EventListenerListeners = Record<string, Function>;\r\n// export type EventListenerListeners = Record<string, (...args: any[]) => any>;\r\n// export type EventListenerListeners = {[name in string]: Function};\r\n\r\n/**\r\n * Better not to remove listeners during setting\r\n * Should add listener callback only once\r\n */\r\n\r\ntype ListenerObject<T> = {callback: T, options: boolean | AddEventListenerOptions};\r\n\r\n// type EventLitenerCallback<T> = (data: T) =>\r\n// export default class EventListenerBase<Listeners extends {[name: string]: Function}> {\r\nexport default class EventListenerBase<Listeners extends EventListenerListeners> {\r\n  protected listeners: Partial<{\r\n    [k in keyof Listeners]: Array<ListenerObject<Listeners[k]>>\r\n  }>;\r\n  protected listenerResults: Partial<{\r\n    [k in keyof Listeners]: ArgumentTypes<Listeners[k]>\r\n  }>;\r\n\r\n  private reuseResults: boolean;\r\n\r\n  constructor(reuseResults?: boolean) {\r\n    this._constructor(reuseResults);\r\n  }\r\n\r\n  public _constructor(reuseResults = false): any {\r\n    this.reuseResults = reuseResults;\r\n    this.listeners = {};\r\n    this.listenerResults = {};\r\n  }\r\n\r\n  public addEventListener<T extends keyof Listeners>(name: T, callback: Listeners[T], options?: boolean | AddEventListenerOptions) {\r\n    (this.listeners[name] ?? (this.listeners[name] = [])).push({callback, options}); // ! add before because if you don't, you won't be able to delete it from callback\r\n\r\n    if(this.listenerResults.hasOwnProperty(name)) {\r\n      callback(...this.listenerResults[name]);\r\n\r\n      if((options as AddEventListenerOptions)?.once) {\r\n        this.listeners[name].pop();\r\n        return;\r\n      }\r\n    }\r\n\r\n    // e.add(this, name, {callback, once});\r\n  }\r\n\r\n  public addMultipleEventsListeners(obj: {\r\n    [name in keyof Listeners]?: Listeners[name]\r\n  }) {\r\n    for(const i in obj) {\r\n      this.addEventListener(i, obj[i]);\r\n    }\r\n  }\r\n\r\n  public removeEventListener<T extends keyof Listeners>(name: T, callback: Listeners[T], options?: boolean | AddEventListenerOptions) {\r\n    if(this.listeners[name]) {\r\n      findAndSplice(this.listeners[name], l => l.callback === callback);\r\n    }\r\n    // e.remove(this, name, callback);\r\n  }\r\n\r\n  protected invokeListenerCallback<T extends keyof Listeners, L extends ListenerObject<any>>(name: T, listener: L, ...args: ArgumentTypes<L['callback']>) {\r\n    let result: any;\r\n    try {\r\n      result = listener.callback(...args);\r\n    } catch(err) {\r\n      console.error(err);\r\n    }\r\n\r\n    if((listener.options as AddEventListenerOptions)?.once) {\r\n      this.removeEventListener(name, listener.callback);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private _dispatchEvent<T extends keyof Listeners>(name: T, collectResults: boolean, ...args: ArgumentTypes<Listeners[T]>) {\r\n    if(this.reuseResults) {\r\n      this.listenerResults[name] = args;\r\n    }\r\n\r\n    const arr: Array<SuperReturnType<Listeners[typeof name]>> = collectResults && [];\r\n\r\n    const listeners = this.listeners[name];\r\n    if(listeners) {\r\n      // ! this one will guarantee execution even if delete another listener during setting\r\n      const left = listeners.slice();\r\n      left.forEach((listener) => {\r\n        const index = listeners.findIndex((l) => l.callback === listener.callback);\r\n        if(index === -1) {\r\n          return;\r\n        }\r\n\r\n        const result = this.invokeListenerCallback(name, listener, ...args);\r\n        if(arr) {\r\n          arr.push(result);\r\n        }\r\n      });\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  public dispatchResultableEvent<T extends keyof Listeners>(name: T, ...args: ArgumentTypes<Listeners[T]>) {\r\n    return this._dispatchEvent(name, true, ...args);\r\n  }\r\n\r\n  // * must be protected, but who cares\r\n  public dispatchEvent<L extends EventListenerListeners = Listeners, T extends keyof L = keyof L>(name: T, ...args: ArgumentTypes<L[T]>) {\r\n    // @ts-ignore\r\n    this._dispatchEvent(name, false, ...args);\r\n  }\r\n\r\n  public cleanup() {\r\n    this.listeners = {};\r\n    this.listenerResults = {};\r\n  }\r\n}\r\n","export default function makeError(type: Error['type']) {\n  const error: ApiError = {\n    type\n  };\n\n  return error;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport DEBUG from '../../config/debug';\nimport ctx from '../../environment/ctx';\nimport indexOfAndSplice from '../../helpers/array/indexOfAndSplice';\nimport {IS_WORKER} from '../../helpers/context';\nimport EventListenerBase from '../../helpers/eventListenerBase';\nimport makeError from '../../helpers/makeError';\nimport {Awaited, WorkerTaskTemplate, WorkerTaskVoidTemplate} from '../../types';\nimport {logger} from '../logger';\n\ntype SuperMessagePortTask = WorkerTaskTemplate & {\n  transfer?: Transferable[]\n};\n\ninterface InvokeTask extends SuperMessagePortTask {\n  type: 'invoke',\n  payload: WorkerTaskVoidTemplate & {withAck?: boolean, void?: boolean}\n}\n\ninterface ResultTask extends SuperMessagePortTask {\n  type: 'result',\n  payload: {\n    taskId: number,\n    result?: any,\n    error?: any\n  }\n}\n\ninterface AckTask extends SuperMessagePortTask {\n  type: 'ack',\n  payload: {\n    cached: boolean,\n    taskId: number\n    result?: any,\n    error?: any,\n  }\n}\n\ninterface PingTask extends SuperMessagePortTask {\n  type: 'ping'\n}\n\ninterface PongTask extends SuperMessagePortTask {\n  type: 'pong'\n}\n\ninterface BatchTask extends SuperMessagePortTask {\n  type: 'batch',\n  payload: Task[]\n}\n\ninterface CloseTask extends SuperMessagePortTask {\n  type: 'close'\n}\n\n// interface OpenTask extends SuperMessagePortTask {\n//   type: 'open'\n// }\n\ninterface LockTask extends SuperMessagePortTask {\n  type: 'lock',\n  payload: string\n}\n\ntype Task = InvokeTask | ResultTask | AckTask | PingTask | PongTask | BatchTask | CloseTask/*  | OpenTask */ | LockTask;\ntype TaskMap = {\n  [type in Task as type['type']]?: (task: Extract<Task, type>, source: MessageEventSource, event: MessageEvent<any>) => void | Promise<any>\n};\n\nexport type AckedResult<T> = {\n  cached: boolean,\n  result: Promise<T>\n};\n// export type AckedResult<T> = {\n//   cached: true,\n//   result: T\n// } | {\n//   cached: false,\n//   result: Promise<T>\n// };\n\ntype ListenPort = WindowProxy | MessagePort | ServiceWorker | Worker | ServiceWorkerContainer;\ntype SendPort = Pick<MessageEventSource, 'postMessage'>/* WindowProxy | MessagePort | ServiceWorker | Worker */;\n\nexport type MessageListenPort = ListenPort;\nexport type MessageSendPort = SendPort;\n\ntype ListenerCallback = (payload: any, source: MessageEventSource, event: MessageEvent<any>) => any;\ntype Listeners = Record<string, ListenerCallback>;\n\n// const PING_INTERVAL = DEBUG && false ? 0x7FFFFFFF : 5000;\n// const PING_TIMEOUT = DEBUG && false ? 0x7FFFFFFF : 10000;\n\nexport default class SuperMessagePort<\n  Workers extends Listeners,\n  Masters extends Listeners,\n  IsMaster extends boolean,\n  Receive extends Listeners = IsMaster extends true ? Masters : Workers,\n  Send extends Listeners = IsMaster extends true ? Workers : Masters\n> extends EventListenerBase<Receive> {\n  protected listenPorts: Array<ListenPort>;\n  protected sendPorts: Array<SendPort>;\n  protected pingResolves: Map<SendPort, () => void>;\n\n  protected taskId: number;\n  protected awaiting: {\n    [id: number]: {\n      resolve: any,\n      reject: any,\n      taskType: string,\n      port?: SendPort\n    }\n  };\n  protected pending: Map<SendPort, Task[]>;\n\n  protected log: ReturnType<typeof logger>;\n  protected debug: boolean;\n  protected releasingPending: boolean;\n\n  protected processTaskMap: TaskMap;\n\n  protected onPortDisconnect: (source: MessageEventSource) => void;\n  // protected onPortConnect: (source: MessageEventSource) => void;\n\n  constructor(logSuffix?: string) {\n    super(false);\n\n    this.listenPorts = [];\n    this.sendPorts = [];\n    this.pingResolves = new Map();\n    this.taskId = 0;\n    this.awaiting = {};\n    this.pending = new Map();\n    this.log = logger('MP' + (logSuffix ? '-' + logSuffix : ''));\n    this.debug = DEBUG;\n\n    if(typeof(window) !== 'undefined') {\n      if('locks' in navigator) {\n        const id = 'lock-' + Date.now() + (Math.random() * 0xFFFF | 0);\n        navigator.locks.request(id, () => new Promise(() => {}));\n        this.pushTask(this.createTask('lock', id));\n      } else {\n        window.addEventListener('beforeunload', () => {\n          const task = this.createTask('close', undefined);\n          this.postMessage(undefined, task);\n        });\n      }\n    }\n\n    this.processTaskMap = {\n      result: this.processResultTask,\n      ack: this.processAckTask,\n      invoke: this.processInvokeTask,\n      ping: this.processPingTask,\n      pong: this.processPongTask,\n      close: this.processCloseTask,\n      // open: this.processOpenTask,\n      lock: this.processLockTask\n    };\n  }\n\n  public setOnPortDisconnect(callback: (source: MessageEventSource) => void) {\n    this.onPortDisconnect = callback;\n  }\n\n  // public setOnPortConnect(callback: (source: MessageEventSource) => void) {\n  //   this.onPortConnect = callback;\n  // }\n\n  public attachPort(port: MessageEventSource) {\n    this.attachListenPort(port);\n    this.attachSendPort(port);\n  }\n\n  public attachListenPort(port: ListenPort) {\n    this.listenPorts.push(port);\n    port.addEventListener('message', this.onMessage as any);\n  }\n\n  public attachSendPort(port: SendPort) {\n    this.log.warn('attaching send port');\n\n    (port as MessagePort).start?.();\n\n    this.sendPorts.push(port);\n    // this.sendPing(port);\n\n    // const task = this.createTask('open', undefined);\n    // this.postMessage(port, task);\n\n    this.releasePending();\n  }\n\n  // ! Can't rely on ping because timers can be suspended\n  // protected sendPing(port: SendPort, loop = IS_WORKER) {\n  //   let timeout: number;\n  //   const promise = new Promise<void>((resolve, reject) => {\n  //     this.pingResolves.set(port, resolve);\n  //     this.pushTask(this.createTask('ping', undefined), port);\n\n  //     timeout = ctx.setTimeout(() => {\n  //       reject();\n  //     }, PING_TIMEOUT);\n  //   });\n\n  //   promise.then(() => {\n  //     // this.log('got pong');\n\n  //     clearTimeout(timeout);\n  //     this.pingResolves.delete(port);\n\n  //     if(loop) {\n  //       this.sendPingWithTimeout(port);\n  //     }\n  //   }, () => {\n  //     this.pingResolves.delete(port);\n  //     this.detachPort(port);\n  //   });\n  // }\n\n  // protected sendPingWithTimeout(port: SendPort, timeout = PING_INTERVAL) {\n  //   ctx.setTimeout(() => {\n  //     if(!this.sendPorts.includes(port)) {\n  //       return;\n  //     }\n\n  //     this.sendPing(port);\n  //   }, timeout);\n  // }\n\n  public detachPort(port: ListenPort) {\n    this.log.warn('disconnecting port');\n\n    indexOfAndSplice(this.listenPorts, port);\n    indexOfAndSplice(this.sendPorts, port as any);\n\n    port.removeEventListener?.('message', this.onMessage as any);\n    (port as MessagePort).close?.();\n\n    this.onPortDisconnect?.(port as any);\n\n    const error = makeError('PORT_DISCONNECTED');\n    for(const id in this.awaiting) {\n      const task = this.awaiting[id];\n      if(task.port === port) {\n        task.reject(error);\n        delete this.awaiting[id];\n      }\n    }\n  }\n\n  protected postMessage(port: SendPort | SendPort[], task: Task) {\n    const ports = Array.isArray(port) ? port : (port ? [port] : this.sendPorts);\n    ports.forEach((port) => {\n      port.postMessage(task, task.transfer as any);\n    });\n  }\n\n  protected onMessage = (event: MessageEvent) => {\n    const task: Task = event.data;\n    // this.log('got message', task);\n\n    const source: MessageEventSource = event.source || event.currentTarget as any; // can have no source\n    /* if(task.type === 'batch') {\n      const newEvent: MessageEvent = {data: event.data, source: event.source, currentTarget: event.currentTarget} as any;\n      task.payload.forEach((task) => {\n        // @ts-ignore\n        newEvent.data = task;\n        this.onMessage(newEvent);\n      });\n    } */\n\n    // @ts-ignore\n    this.processTaskMap[task.type](task, source, event);\n  };\n\n  protected /* async */ releasePending() {\n    // return;\n\n    if(/* !this.listenPorts.length || !this.sendPorts.length ||  */this.releasingPending) {\n      return;\n    }\n\n    this.releasingPending = true;\n    // const perf = performance.now();\n    // await pause(0);\n\n    this.debug && this.log.debug('releasing tasks, length:', this.pending.size/* , performance.now() - perf */);\n\n    this.pending.forEach((portTasks, port) => {\n      // let batchTask: BatchTask;\n      // const tasks: Task[] = [];\n      // portTasks.forEach((task) => {\n      //   if(task.transfer) {\n      //     batchTask = undefined;\n      //     tasks.push(task);\n      //   } else {\n      //     if(!batchTask) {\n      //       batchTask = this.createTask('batch', []);\n      //       tasks.push(batchTask);\n      //     }\n\n      //     batchTask.payload.push(task);\n      //   }\n      // });\n\n      const tasks = portTasks;\n      const ports = port ? [port] : this.sendPorts;\n      if(!ports.length) {\n        return;\n      }\n\n      tasks.forEach((task) => {\n        // if(task.type === 'batch') {\n        //   this.log(`batching ${task.payload.length} tasks`);\n        // }\n\n        try {\n          // if(IS_SERVICE_WORKER && !port) {\n          //   notifyAll(task);\n          // } else {\n          this.postMessage(ports, task);\n          // }\n        } catch(err) {\n          this.log.error('postMessage error:', err, task, ports);\n        }\n      });\n\n      this.pending.delete(port);\n    });\n\n    this.debug && this.log.debug('released tasks');\n\n    this.releasingPending = false;\n  }\n\n  protected processResultTask = (task: ResultTask) => {\n    const {taskId, result, error} = task.payload;\n    const deferred = this.awaiting[taskId];\n    if(!deferred) {\n      return;\n    }\n\n    this.debug && this.log.debug('done', deferred.taskType, result, error);\n    'error' in task.payload ? deferred.reject(error) : deferred.resolve(result);\n    delete this.awaiting[taskId];\n  };\n\n  protected processAckTask = (task: AckTask) => {\n    const payload = task.payload;\n    const deferred = this.awaiting[payload.taskId];\n    if(!deferred) {\n      return;\n    }\n\n    // * will finish the init promise with incoming result\n    const previousResolve: (acked: AckedResult<any>) => void = deferred.resolve;\n    // const previousReject = deferred.reject;\n\n    // if(payload.cached) {\n    //   if('result' in payload) {\n    //     previousResolve({\n    //       cached: true,\n    //       result: payload.result\n    //     });\n    //   } else {\n    //     previousReject(payload.error);\n    //   }\n    // } else {\n    //   const ret: AckedResult<any> = {\n    //     cached: false,\n    //     result: new Promise((resolve, reject) => {\n    //       deferred.resolve = resolve;\n    //       deferred.reject = reject;\n    //     })\n    //   };\n\n    //   previousResolve(ret);\n    // }\n\n    const ret: AckedResult<any> = {\n      cached: payload.cached,\n      result: payload.cached ? ('result' in payload ? Promise.resolve(payload.result) : Promise.reject(payload.error)) : new Promise((resolve, reject) => {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n      })\n    };\n\n    previousResolve(ret);\n\n    if(payload.cached) {\n      delete this.awaiting[payload.taskId];\n    }\n  };\n\n  protected processPingTask = (task: PingTask, source: MessageEventSource, event: MessageEvent) => {\n    this.pushTask(this.createTask('pong', undefined), event.source);\n  };\n\n  protected processPongTask = (task: PongTask, source: MessageEventSource, event: MessageEvent) => {\n    const pingResolve = this.pingResolves.get(source);\n    if(pingResolve) {\n      this.pingResolves.delete(source);\n      pingResolve();\n    }\n  };\n\n  protected processCloseTask = (task: CloseTask, source: MessageEventSource, event: MessageEvent) => {\n    this.detachPort(source);\n  };\n\n  // * it's just an 'open' callback, DO NOT attach port from here\n  // protected processOpenTask = (task: OpenTask, source: MessageEventSource, event: MessageEvent) => {\n  //   this.onPortConnect?.(source);\n  // };\n\n  protected processLockTask = (task: LockTask, source: MessageEventSource, event: MessageEvent) => {\n    navigator.locks.request(task.payload, () => {\n      this.processCloseTask(undefined, source, undefined);\n    });\n  };\n\n  protected processInvokeTask = async(task: InvokeTask, source: MessageEventSource, event: MessageEvent) => {\n    const id = task.id;\n    const innerTask = task.payload;\n\n    let resultTaskPayload: ResultTask['payload'];\n    let resultTask: ResultTask, ackTask: AckTask;\n    if(!innerTask.void) {\n      resultTaskPayload = {taskId: id};\n      resultTask = this.createTask('result', resultTaskPayload);\n    }\n\n    if(innerTask.withAck) {\n      ackTask = this.createTask('ack', {\n        taskId: id,\n        cached: true\n      });\n    }\n\n    let isPromise: boolean;\n    try {\n      const listeners = this.listeners[innerTask.type];\n      if(!listeners?.length) {\n        throw new Error('no listener');\n      }\n\n      const listener = listeners[0];\n\n      // @ts-ignore\n      let result = this.invokeListenerCallback(innerTask.type, listener, innerTask.payload, source, event);\n      if(innerTask.void) {\n        return;\n      }\n\n      isPromise = result instanceof Promise;\n\n      if(ackTask) {\n        const cached = !isPromise;\n        ackTask.payload.cached = cached;\n        if(cached) ackTask.payload.result = result;\n        this.pushTask(ackTask, source);\n\n        if(cached) {\n          return;\n        }\n      }\n\n      if(isPromise) {\n        result = await result;\n      }\n\n      resultTaskPayload.result = result;\n    } catch(error) {\n      this.log.error('worker task error:', error, task);\n      if(innerTask.void) {\n        return;\n      }\n\n      if(ackTask && ackTask.payload.cached) {\n        ackTask.payload.error = error;\n        this.pushTask(ackTask, source);\n        return;\n      }\n\n      resultTaskPayload.error = error;\n    }\n\n    this.pushTask(resultTask, source);\n  };\n\n  protected createTask<T extends Task['type'], K extends Task = Parameters<TaskMap[T]>[0]>(type: T, payload: K['payload'], transfer?: Transferable[]): K {\n    return {\n      type,\n      payload,\n      id: this.taskId++,\n      transfer\n    } as K;\n  }\n\n  protected createInvokeTask(type: string, payload: any, withAck?: boolean, _void?: boolean, transfer?: Transferable[]): InvokeTask {\n    return this.createTask('invoke', {\n      type,\n      payload,\n      withAck,\n      void: _void\n    }, transfer);\n  }\n\n  protected pushTask(task: Task, port?: SendPort) {\n    let tasks = this.pending.get(port);\n    if(!tasks) {\n      this.pending.set(port, tasks = []);\n    }\n\n    tasks.push(task);\n    this.releasePending();\n  }\n\n  public invokeVoid<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], port?: SendPort, transfer?: Transferable[]) {\n    const task = this.createInvokeTask(type as string, payload, undefined, true, transfer);\n    this.pushTask(task, port);\n  }\n\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: false, port?: SendPort, transfer?: Transferable[]): Promise<Awaited<ReturnType<Send[T]>>>;\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: true, port?: SendPort, transfer?: Transferable[]): Promise<AckedResult<Awaited<ReturnType<Send[T]>>>>;\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: boolean, port?: SendPort, transfer?: Transferable[]) {\n    this.debug && this.log.debug('start', type, payload);\n\n    let task: InvokeTask;\n    const promise = new Promise<Awaited<ReturnType<Send[T]>>>((resolve, reject) => {\n      task = this.createInvokeTask(type as string, payload, withAck, undefined, transfer);\n      this.awaiting[task.id] = {resolve, reject, taskType: type as string, port};\n      this.pushTask(task, port);\n    });\n\n    if(IS_WORKER) {\n      promise.finally(() => {\n        clearInterval(interval);\n      });\n\n      const interval = ctx.setInterval(() => {\n        this.log.error('task still has no result', task, port);\n      }, 5e3);\n    } else if(false) {\n      // let timedOut = false;\n      const startTime = Date.now();\n      promise.finally(() => {\n        const elapsedTime = Date.now() - startTime;\n        if(elapsedTime >= TIMEOUT) {\n          this.log.error(`task was processing ${Date.now() - startTime}ms`, task.payload.payload, port);\n        }/*  else {\n          clearTimeout(timeout);\n        } */\n      });\n\n      const TIMEOUT = 10;\n      // const timeout = ctx.setTimeout(() => {\n      //   timedOut = true;\n      //   // this.log.error(`task is processing more than ${TIMEOUT} milliseconds`, task, port);\n      // }, TIMEOUT);\n    }\n\n    return promise;\n  }\n\n  public invokeExceptSource<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], source?: SendPort) {\n    const ports = this.sendPorts.slice();\n    indexOfAndSplice(ports, source);\n\n    ports.forEach((target) => {\n      this.invokeVoid(type, payload, target);\n    });\n  }\n}\n"],"names":["DEBUG","MOUNT_CLASS_TO","window","self","Modes","test","location","search","indexOf","debug","http","ssl","multipleConnections","asServiceWorker","transport","findAndSplice","array","verify","index","findIndex","splice","undefined","indexOfAndSplice","item","idx","spliced","_logTimer","Date","now","dT","toFixed","EventListenerBase","constructor","reuseResults","this","_constructor","listeners","listenerResults","addEventListener","name","callback","options","push","hasOwnProperty","once","pop","addMultipleEventsListeners","obj","i","removeEventListener","l","invokeListenerCallback","listener","args","result","err","console","error","_dispatchEvent","collectResults","arr","slice","forEach","dispatchResultableEvent","dispatchEvent","cleanup","makeError","type","SuperMessagePort","logSuffix","super","onMessage","event","task","data","source","currentTarget","processTaskMap","processResultTask","taskId","payload","deferred","awaiting","log","taskType","reject","resolve","processAckTask","previousResolve","cached","Promise","processPingTask","pushTask","createTask","processPongTask","pingResolve","pingResolves","get","delete","processCloseTask","detachPort","processLockTask","navigator","locks","request","processInvokeTask","id","innerTask","resultTaskPayload","resultTask","ackTask","isPromise","void","withAck","length","Error","listenPorts","sendPorts","Map","pending","Math","random","postMessage","ack","invoke","ping","pong","close","lock","setOnPortDisconnect","onPortDisconnect","attachPort","port","attachListenPort","attachSendPort","warn","start","releasePending","Array","isArray","transfer","releasingPending","size","portTasks","tasks","ports","createInvokeTask","_void","set","invokeVoid","promise","finally","clearInterval","interval","invokeExceptSource","target"],"sourceRoot":""}