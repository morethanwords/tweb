import{$ as b,y as l,fa as u,fb as y,C as U,fq as d,aG as w}from"./index-DfTYkYxh.js";const H=32,S=16;function M(a,e){return a.length===e.length&&a.every((n,s)=>n===e[s])}const P=1e5;async function E(a,e){const s=new TextEncoder().encode(a);a="";const i=await crypto.subtle.importKey("raw",s,{name:"PBKDF2"},!1,["deriveBits"]),p=await crypto.subtle.deriveBits({name:"PBKDF2",salt:e,iterations:P,hash:"SHA-256"},i,256);return new Uint8Array(p)}async function k(a,e){const s=new TextEncoder().encode(a);a="";const i=await crypto.subtle.importKey("raw",s,{name:"PBKDF2"},!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:P,hash:"SHA-256"},i,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async function h(a){const e=crypto.getRandomValues(new Uint8Array(S)),n=crypto.getRandomValues(new Uint8Array(S)),s=await k(a,e),i=await E(a,n);return a="",{verificationHash:i,verificationSalt:n,encryptionSalt:e,encryptionKey:s}}function B(){const{rootScope:a,apiManagerProxy:e}=b();async function n(){d.temporarilyToggle(!1),await e.invoke("toggleCacheStorage",!1),await e.serviceMessagePort.invoke("toggleCacheStorage",!1)}async function s(){d.temporarilyToggle(!0),await e.invoke("toggleCacheStorage",!0),await e.serviceMessagePort.invoke("toggleCacheStorage",!0)}async function i(){await d.clearEncryptableStorages(),d.resetOpenEncryptableCacheStorages(),await Promise.all([e.invoke("resetEncryptableCacheStorages",void 0),e.serviceMessagePort.invoke("resetEncryptableCacheStorages",void 0)])}async function p(t){const{verificationHash:o,verificationSalt:c,encryptionSalt:v,encryptionKey:r}=await h(t);t="",await l.set({passcode:{verificationHash:o,verificationSalt:c,encryptionSalt:v}});const[,g]=w();await g("passcode","enabled",!0),await n(),await i();const f={isUsingPasscode:!0,encryptionKey:r};await e.invoke("toggleUsingPasscode",f),await e.serviceMessagePort.invoke("toggleUsingPasscode",f),a.dispatchEvent("toggle_using_passcode",!0),u.resolveDeferred(!0),y.save(r),await s(),await U.updateStorageForLegacy(null)}async function m(t){const o=await l.get("passcode",!1);if(!o?.verificationHash||!o?.verificationSalt)return!1;const c=await E(t,o.verificationSalt);return t="",M(c,o.verificationHash)}async function K(){const[,t]=w();await t("passcode","enabled",!1),a.dispatchEvent("toggle_using_passcode",!1),await n(),await i(),await e.invoke("toggleUsingPasscode",{isUsingPasscode:!1}),await e.serviceMessagePort.invoke("toggleUsingPasscode",{isUsingPasscode:!1}),y.save(null),u.resolveDeferred(!1),await s(),l.delete("passcode")}async function A(t){const{verificationHash:o,verificationSalt:c,encryptionSalt:v,encryptionKey:r}=await h(t);t="";const g={verificationHash:o,verificationSalt:c,encryptionSalt:v};await n(),await i(),await e.invoke("changePasscode",{toStore:g,encryptionKey:r}),await e.serviceMessagePort.invoke("saveEncryptionKey",r),y.save(r),await s(),await l.set({passcode:g},!0)}async function C(t){const o=await l.get("passcode",!1);if(!o?.encryptionSalt)throw new Error("No encryption salt found in storage");const c=await k(t,o.encryptionSalt);t="",y.save(c),await e.invoke("saveEncryptionKey",c),await e.serviceMessagePort.invoke("toggleUsingPasscode",{isUsingPasscode:!0,encryptionKey:c}),e.invokeVoid("toggleLockOthers",!1),a.dispatchEvent("toggle_locked",!1)}return{enablePasscode:p,isMyPasscode:m,disablePasscode:K,changePasscode:A,unlockWithPasscode:C}}export{H as M,B as u};
//# sourceMappingURL=actions-CdLCaY8z.js.map
