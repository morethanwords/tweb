{"version":3,"file":"scrollable2-B9qrN0bL.js","sources":["../src/components/scrollable2.tsx"],"sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {children, createContext, createEffect, createMemo, createSignal, JSX, on, onCleanup, Ref} from 'solid-js';\nimport {IS_OVERLAY_SCROLL_SUPPORTED} from '@environment/overlayScrollSupport';\nimport IS_TOUCH_SUPPORTED from '@environment/touchSupport';\nimport {IS_MOBILE_SAFARI, IS_SAFARI} from '@environment/userAgent';\nimport cancelEvent from '@helpers/dom/cancelEvent';\nimport classNames from '@helpers/string/classNames';\nimport useHeavyAnimationCheck from '@hooks/useHeavyAnimationCheck';\n\nconst SCROLL_THROTTLE = /* IS_ANDROID ? 200 :  */24;\nconst USE_OWN_SCROLL = !IS_OVERLAY_SCROLL_SUPPORTED;\n\nlet throttleMeasurement: (callback: () => void) => number,\n  cancelMeasurement: (id: number) => void;\nif(USE_OWN_SCROLL) {\n  throttleMeasurement = (callback) => requestAnimationFrame(callback);\n  cancelMeasurement = (id) => cancelAnimationFrame(id);\n} else {\n  throttleMeasurement = (callback) => window.setTimeout(callback, SCROLL_THROTTLE);\n  cancelMeasurement = (id) => window.clearTimeout(id);\n}\n\nexport type ScrollableContextValue = {\n  scrollPosition: number,\n  scrollSize: number,\n  clientSize: number,\n  offsetSize: number,\n  getDistanceToEnd: () => number,\n  container: HTMLDivElement,\n  onSizeChange: () => void,\n  setScrollPositionSilently: (value: number) => void\n};\n\nexport const ScrollableContext = createContext<ScrollableContextValue>();\n\nexport default function Scrollable(props: {\n  children: JSX.Element,\n  ref?: Ref<HTMLDivElement>,\n  thumbRef?: (el: HTMLDivElement) => void,\n  class?: string,\n  classList?: JSX.HTMLAttributes<HTMLDivElement>['classList'],\n  axis?: 'x' | 'y',\n  withBorders?: 'both' | 'top' | 'bottom' | 'manual',\n  onScrolledTop?: () => void,\n  onScrolledBottom?: () => void,\n  onScroll?: () => void,\n  onScrollOffset?: number,\n  relative?: boolean\n}) {\n  const axis = props.axis ?? 'y';\n  const scrollPositionProperty: 'scrollTop' | 'scrollLeft' = axis === 'x' ? 'scrollLeft' : 'scrollTop';\n  const scrollSizeProperty: 'scrollHeight' | 'scrollWidth' = axis === 'x' ? 'scrollWidth' : 'scrollHeight';\n  const clientSizeProperty: 'clientHeight' | 'clientWidth' = axis === 'x' ? 'clientWidth' : 'clientHeight';\n  const offsetSizeProperty: 'offsetHeight' | 'offsetWidth' = axis === 'x' ? 'offsetWidth' : 'offsetHeight';\n  const clientAxis: 'clientY' | 'clientX' = axis === 'x' ? 'clientX' : 'clientY';\n\n  const [ignoreScrollEvent, setIgnoreScrollEvent] = createSignal(false);\n  const scrollPosition = () => ref[scrollPositionProperty];\n  const setScrollPosition = (value: number) => ref[scrollPositionProperty] = value;\n  const scrollSize = () => ref[scrollSizeProperty];\n  const clientSize = () => ref[clientSizeProperty];\n  const offsetSize = () => ref[offsetSizeProperty];\n  const getDistanceToEnd = () => scrollSize() - Math.round(scrollPosition() + offsetSize());\n\n  const onScrollOffset = createMemo(() => props.onScrollOffset ?? 300);\n\n  let lastScrollDirection: -1 | 0 | 1 = 0;\n  let lastScrollPosition = 0;\n\n  let startMousePosition: number;\n  let startScrollPosition: number;\n\n  let isHeavyAnimationInProgress = false;\n  let needCheckAfterAnimation = false;\n\n  const [isScrolledToStart, setIsScrolledToStart] = createSignal(true);\n  const [isScrolledToEnd, setIsScrolledToEnd] = createSignal(true);\n\n  let onScrollMeasure = 0;\n\n  const removeHeavyAnimationListener = useHeavyAnimationCheck(() => {\n    isHeavyAnimationInProgress = true;\n\n    if(onScrollMeasure) {\n      cancelMeasure();\n      needCheckAfterAnimation = true;\n    }\n  }, () => {\n    isHeavyAnimationInProgress = false;\n\n    if(needCheckAfterAnimation) {\n      onScroll();\n      needCheckAfterAnimation = false;\n    }\n  });\n\n  onCleanup(removeHeavyAnimationListener);\n\n  const onScroll = () => {\n    // if(this.debug) {\n    // this.log('onScroll call', this.onScrollMeasure);\n    // }\n\n    // return;\n\n    if(isHeavyAnimationInProgress) {\n      cancelMeasure();\n      needCheckAfterAnimation = true;\n      return;\n    }\n\n    // if(this.onScrollMeasure || ((this.scrollLocked || (!this.onScrolledTop && !this.onScrolledBottom)) && !this.splitUp && !this.onAdditionalScroll)) return;\n    if((!props.onScrolledTop && !props.onScrolledBottom)/*  && !this.splitUp */ && !onScrollCallbacks().length && !USE_OWN_SCROLL) return;\n    if(onScrollMeasure) return;\n    onScrollMeasure = throttleMeasurement(() => {\n      onScrollMeasure = 0;\n\n      const _scrollPosition = scrollPosition();\n      lastScrollDirection = lastScrollPosition === _scrollPosition ? 0 : (lastScrollPosition < _scrollPosition ? 1 : -1); // * 1 - bottom, -1 - top\n      lastScrollPosition = _scrollPosition;\n\n      updateThumb(_scrollPosition);\n\n      // lastScrollDirection check is useless here, every callback should decide on its own\n      if(true/*  && lastScrollDirection !== 0 */) {\n        onScrollCallbacks().forEach((callback) => callback());\n      }\n\n      checkForTriggers();\n    });\n  };\n\n  const cancelMeasure = () => {\n    if(onScrollMeasure) {\n      cancelMeasurement(onScrollMeasure);\n      onScrollMeasure = 0;\n    }\n  };\n\n  const checkForTriggers = () => {\n    if(!props.onScrolledTop && !props.onScrolledBottom) return;\n\n    // if(this.isHeavyAnimationInProgress) {\n    //   this.onScroll();\n    //   return;\n    // }\n\n    const _scrollSize = scrollSize();\n    if(!_scrollSize) { // незачем вызывать триггеры если блок пустой или не виден\n      return;\n    }\n\n    const _scrollPosition = scrollPosition();\n    const _clientSize = offsetSize();\n    const _onScrollOffset = onScrollOffset();\n    const maxScrollPosition = _scrollSize - _clientSize;\n\n    // this.log('checkForTriggers:', scrollTop, maxScrollTop);\n\n    if(props.onScrolledTop && _scrollPosition <= _onScrollOffset && lastScrollDirection <= 0/* && direction === -1 */) {\n      props.onScrolledTop();\n    }\n\n    if(props.onScrolledBottom && (maxScrollPosition - _scrollPosition) <= _onScrollOffset && lastScrollDirection >= 0/* && direction === 1 */) {\n      props.onScrolledBottom();\n    }\n  };\n\n  const checkEnds = () => {\n    setIsScrolledToStart(!scrollPosition());\n    setIsScrolledToEnd(getDistanceToEnd() <= 1);\n  };\n\n  const updateThumb = (_scrollPosition = scrollPosition()) => {\n    if(!USE_OWN_SCROLL || !thumbRef) {\n      return;\n    }\n\n    const _scrollSize = scrollSize();\n    const _clientSize = clientSize();\n    const divider = _scrollSize / _clientSize / 0.75;\n    const thumbSize = Math.max(20, _clientSize / divider);\n    const value = _scrollPosition / (_scrollSize - _clientSize) * _clientSize;\n    // const b = (scrollPosition + clientSize) / scrollSize;\n    const b = _scrollPosition / (_scrollSize - _clientSize);\n    const maxValue = _clientSize - thumbSize;\n    if(_clientSize < _scrollSize) {\n      thumbRef.style.height = thumbSize + 'px';\n      // this.thumb.style.top = `${Math.min(maxValue, value - thumbSize * b)}px`;\n      thumbRef.style.transform = `translateY(${Math.min(maxValue, value - thumbSize * b)}px)`;\n    } else {\n      thumbRef.style.height = '0px';\n    }\n  };\n\n  const setScrollPositionSilently = (value: number) => {\n    lastScrollPosition = value;\n    ignoreNextScrollEvent();\n\n    setScrollPosition(value);\n  };\n\n  const ignoreNextScrollEvent = () => {\n    setIgnoreScrollEvent(true);\n    ref.addEventListener('scroll', (e) => {\n      cancelEvent(e);\n      setIgnoreScrollEvent(false);\n      // this.addScrollListener();\n    }, {capture: true, passive: false, once: true});\n  };\n\n  const onScrollCallbacks = createMemo(() => [props.onScroll, props.withBorders && checkEnds].filter(Boolean));\n\n  const onThumbMouseMove = (e: MouseEvent) => {\n    cancelEvent(e);\n\n    const contentHeight = scrollSize();\n    const viewportHeight = clientSize();\n    const scrollbarSize = thumbRef.offsetHeight;\n    const maxScrollTop = contentHeight - viewportHeight;\n\n    const maxScrollbarOffset = viewportHeight - scrollbarSize;\n    const deltaY = e[clientAxis] - startMousePosition;\n    const scrollAmount = (deltaY / maxScrollbarOffset) * maxScrollTop;\n    const newScrollTop = startScrollPosition + scrollAmount;\n\n    ref[scrollPositionProperty] = newScrollTop;\n  };\n\n  const onThumbMouseDown = (e: MouseEvent) => {\n    cancelEvent(e);\n    startMousePosition = e[clientAxis];\n    startScrollPosition = scrollPosition();\n    (e.target as HTMLElement).classList.add('is-focused');\n\n    window.addEventListener('mousemove', onThumbMouseMove);\n    window.addEventListener('mouseup', onThumbMouseUp, {once: true});\n  };\n\n  const onThumbMouseUp = (e: MouseEvent) => {\n    window.removeEventListener('mousemove', onThumbMouseMove);\n    thumbRef.classList.remove('is-focused');\n  };\n\n  const onWheel = (e: WheelEvent) => {\n    e.stopPropagation();\n    const target = e.target as HTMLElement;\n    if(!e.deltaX && target.scrollWidth > target.clientWidth) {\n      target.scrollLeft += e.deltaY / 4;\n      cancelEvent(e);\n    }\n  };\n\n  const onSizeChange = () => {\n    if(USE_OWN_SCROLL && thumbRef) {\n      onScroll();\n    }\n  };\n\n  const value: ScrollableContextValue = {\n    get scrollPosition() {\n      return scrollPosition();\n    },\n    get scrollSize() {\n      return scrollSize();\n    },\n    get clientSize() {\n      return clientSize();\n    },\n    get offsetSize() {\n      return offsetSize();\n    },\n    getDistanceToEnd,\n    get container() {\n      return ref;\n    },\n    onSizeChange,\n    setScrollPositionSilently\n  };\n\n  const resolvedChildren = children(() => {\n    return (\n      <ScrollableContext.Provider value={value}>\n        {props.children}\n      </ScrollableContext.Provider>\n    );\n  });\n\n  createEffect(on(resolvedChildren, onSizeChange));\n\n  let ref: HTMLDivElement, thumbRef: HTMLDivElement;\n  return (\n    <div\n      ref={(_ref) => {\n        ref = _ref;\n        (props.ref as any)?.(_ref);\n      }}\n      class={classNames(\n        'scrollable',\n        `scrollable-${axis}`,\n        props.class,\n        props.relative && 'relative',\n        IS_SAFARI && !IS_MOBILE_SAFARI && 'no-scrollbar',\n        ...(props.withBorders ? [\n          isScrolledToStart() && 'scrolled-start',\n          isScrolledToEnd() && 'scrolled-end',\n          axis === 'y' && 'scrollable-y-bordered',\n          (props.withBorders === 'top' || props.withBorders === 'both') && 'scrollable-y-bordered-top',\n          (props.withBorders === 'bottom' || props.withBorders === 'both') && 'scrollable-y-bordered-bottom'\n        ] : [])\n      )}\n      onScroll={!ignoreScrollEvent() && onScroll}\n      onWheel={(axis === 'x' && !IS_TOUCH_SUPPORTED && onWheel) || undefined}\n    >\n      {USE_OWN_SCROLL && axis === 'y' && (\n        <div class=\"scrollable-thumb-container\">\n          <div\n            class=\"scrollable-thumb\"\n            ref={(el) => {\n              thumbRef = el;\n              props.thumbRef?.(el);\n            }}\n            onMouseDown={onThumbMouseDown}\n          ></div>\n        </div>\n      )}\n      {resolvedChildren()}\n    </div>\n  );\n}\n"],"names":["SCROLL_THROTTLE","USE_OWN_SCROLL","IS_OVERLAY_SCROLL_SUPPORTED","throttleMeasurement","cancelMeasurement","callback","requestAnimationFrame","id","cancelAnimationFrame","window","setTimeout","clearTimeout","ScrollableContext","createContext","Scrollable","props","axis","scrollPositionProperty","scrollSizeProperty","clientSizeProperty","offsetSizeProperty","clientAxis","ignoreScrollEvent","setIgnoreScrollEvent","createSignal","scrollPosition","ref","setScrollPosition","value","scrollSize","clientSize","offsetSize","getDistanceToEnd","Math","round","onScrollOffset","createMemo","lastScrollDirection","lastScrollPosition","startMousePosition","startScrollPosition","isHeavyAnimationInProgress","needCheckAfterAnimation","isScrolledToStart","setIsScrolledToStart","isScrolledToEnd","setIsScrolledToEnd","onScrollMeasure","removeHeavyAnimationListener","useHeavyAnimationCheck","cancelMeasure","onScroll","onCleanup","onScrolledTop","onScrolledBottom","onScrollCallbacks","length","_scrollPosition","updateThumb","forEach","checkForTriggers","_scrollSize","_clientSize","_onScrollOffset","maxScrollPosition","checkEnds","thumbRef","divider","thumbSize","max","b","maxValue","style","height","transform","min","setScrollPositionSilently","ignoreNextScrollEvent","addEventListener","e","cancelEvent","capture","passive","once","withBorders","filter","Boolean","onThumbMouseMove","contentHeight","viewportHeight","scrollbarSize","offsetHeight","maxScrollTop","maxScrollbarOffset","scrollAmount","newScrollTop","onThumbMouseDown","target","classList","add","onThumbMouseUp","removeEventListener","remove","onWheel","stopPropagation","deltaX","scrollWidth","clientWidth","scrollLeft","deltaY","onSizeChange","container","resolvedChildren","children","_$createComponent","Provider","createEffect","on","_el$","_tmpl$","_$addEventListener","IS_TOUCH_SUPPORTED","undefined","_$use","_ref","_$insert","_el$2","_tmpl$2","_el$3","firstChild","$$mousedown","el","_$effect","_$className","classNames","class","relative","IS_SAFARI","IS_MOBILE_SAFARI","_$delegateEvents"],"mappings":"6VAcMA,GAA2C,GAC3CC,EAAiB,CAACC,GAExB,IAAIC,EACFC,EACCH,GACDE,EAAuBE,GAAaC,sBAAsBD,CAAQ,EAClED,EAAqBG,GAAOC,qBAAqBD,CAAE,IAEnDJ,EAAuBE,GAAaI,OAAOC,WAAWL,EAAUL,EAAe,EAC/EI,EAAqBG,GAAOE,OAAOE,aAAaJ,CAAE,GAcvCK,MAAAA,GAAoBC,GAAuC,EAEzD,SAASC,GAAWC,EAahC,CACD,MAAMC,EAAOD,EAAMC,MAAQ,IACrBC,EAAqDD,IAAS,IAAM,aAAe,YACnFE,EAAqDF,IAAS,IAAM,cAAgB,eACpFG,EAAqDH,IAAS,IAAM,cAAgB,eACpFI,EAAqDJ,IAAS,IAAM,cAAgB,eACpFK,EAAoCL,IAAS,IAAM,UAAY,UAE/D,CAACM,EAAmBC,CAAoB,EAAIC,EAAa,EAAK,EAC9DC,EAAiBA,IAAMC,EAAIT,CAAsB,EACjDU,EAAqBC,GAAkBF,EAAIT,CAAsB,EAAIW,EACrEC,EAAaA,IAAMH,EAAIR,CAAkB,EACzCY,EAAaA,IAAMJ,EAAIP,CAAkB,EACzCY,EAAaA,IAAML,EAAIN,CAAkB,EACzCY,EAAmBA,IAAMH,IAAeI,KAAKC,MAAMT,EAAc,EAAKM,EAAU,CAAE,EAElFI,EAAiBC,EAAW,IAAMrB,EAAMoB,gBAAkB,GAAG,EAEnE,IAAIE,EAAkC,EAClCC,EAAqB,EAErBC,EACAC,EAEAC,EAA6B,GAC7BC,EAA0B,GAE9B,KAAM,CAACC,EAAmBC,CAAoB,EAAIpB,EAAa,EAAI,EAC7D,CAACqB,EAAiBC,CAAkB,EAAItB,EAAa,EAAI,EAE/D,IAAIuB,EAAkB,EAEtB,MAAMC,EAA+BC,GAAuB,IAAM,CAChER,EAA6B,GAE1BM,IACDG,IACAR,EAA0B,GAE9B,EAAG,IAAM,CACPD,EAA6B,GAE1BC,IACDS,IACAT,EAA0B,GAE9B,CAAC,EAEDU,GAAUJ,CAA4B,EAEtC,MAAMG,EAAWA,IAAM,CAOrB,GAAGV,EAA4B,CAC7BS,IACAR,EAA0B,GAC1B,MACF,CAGI,CAAC3B,EAAMsC,eAAiB,CAACtC,EAAMuC,kBAA4C,CAACC,IAAoBC,QAAU,CAACvD,GAC5G8C,IACHA,EAAkB5C,EAAoB,IAAM,CAC1C4C,EAAkB,EAElB,MAAMU,EAAkBhC,IACxBY,EAAsBC,IAAuBmB,EAAkB,EAAKnB,EAAqBmB,EAAkB,EAAI,GAC/GnB,EAAqBmB,EAErBC,GAAYD,CAAe,EAIzBF,EAAmB,EAACI,QAAStD,GAAaA,EAAU,CAAA,EAGtDuD,IACF,CAAC,IAGGV,EAAgBA,IAAM,CACvBH,IACD3C,EAAkB2C,CAAe,EACjCA,EAAkB,IAIhBa,GAAmBA,IAAM,CAC7B,GAAG,CAAC7C,EAAMsC,eAAiB,CAACtC,EAAMuC,iBAAkB,OAOpD,MAAMO,EAAchC,IACpB,GAAG,CAACgC,EACF,OAGF,MAAMJ,EAAkBhC,IAClBqC,EAAc/B,IACdgC,EAAkB5B,IAClB6B,EAAoBH,EAAcC,EAIrC/C,EAAMsC,eAAiBI,GAAmBM,GAAmB1B,GAAuB,GACrFtB,EAAMsC,cAAa,EAGlBtC,EAAMuC,kBAAqBU,EAAoBP,GAAoBM,GAAmB1B,GAAuB,GAC9GtB,EAAMuC,iBAAgB,GAIpBW,GAAYA,IAAM,CACtBrB,EAAqB,CAACnB,EAAc,CAAE,EACtCqB,EAAmBd,KAAsB,CAAC,GAGtC0B,GAAcA,CAACD,EAAkBhC,MAAqB,CAC1D,GAAG,CAACxB,GAAkB,CAACiE,EACrB,OAGF,MAAML,EAAchC,IACdiC,EAAchC,IACdqC,EAAUN,EAAcC,EAAc,IACtCM,EAAYnC,KAAKoC,IAAI,GAAIP,EAAcK,CAAO,EAC9CvC,EAAQ6B,GAAmBI,EAAcC,GAAeA,EAExDQ,EAAIb,GAAmBI,EAAcC,GACrCS,EAAWT,EAAcM,EAC5BN,EAAcD,GACfK,EAASM,MAAMC,OAASL,EAAY,KAEpCF,EAASM,MAAME,UAAa,cAAazC,KAAK0C,IAAIJ,EAAU3C,EAAQwC,EAAYE,CAAC,CAAE,OAEnFJ,EAASM,MAAMC,OAAS,OAItBG,GAA6BhD,GAAkB,CACnDU,EAAqBV,EACrBiD,KAEAlD,EAAkBC,CAAK,GAGnBiD,GAAwBA,IAAM,CAClCtD,EAAqB,EAAI,EACzBG,EAAIoD,iBAAiB,SAAWC,GAAM,CACpCC,EAAYD,CAAC,EACbxD,EAAqB,EAAK,CAE5B,EAAG,CAAC0D,QAAS,GAAMC,QAAS,GAAOC,KAAM,EAAI,CAAC,GAG1C5B,EAAoBnB,EAAW,IAAM,CAACrB,EAAMoC,SAAUpC,EAAMqE,aAAenB,EAAS,EAAEoB,OAAOC,OAAO,CAAC,EAErGC,EAAoBR,GAAkB,CAC1CC,EAAYD,CAAC,EAEb,MAAMS,EAAgB3D,IAChB4D,EAAiB3D,IACjB4D,EAAgBxB,EAASyB,aACzBC,EAAeJ,EAAgBC,EAE/BI,EAAqBJ,EAAiBC,EAEtCI,GADSf,EAAE1D,CAAU,EAAIkB,GACAsD,EAAsBD,EAC/CG,GAAevD,EAAsBsD,EAE3CpE,EAAIT,CAAsB,EAAI8E,IAG1BC,GAAoBjB,GAAkB,CAC1CC,EAAYD,CAAC,EACbxC,EAAqBwC,EAAE1D,CAAU,EACjCmB,EAAsBf,EAAc,EACnCsD,EAAEkB,OAAuBC,UAAUC,IAAI,YAAY,EAEpD1F,OAAOqE,iBAAiB,YAAaS,CAAgB,EACrD9E,OAAOqE,iBAAiB,UAAWsB,GAAgB,CAACjB,KAAM,EAAI,CAAC,GAG3DiB,GAAkBrB,GAAkB,CACxCtE,OAAO4F,oBAAoB,YAAad,CAAgB,EACxDrB,EAASgC,UAAUI,OAAO,YAAY,GAGlCC,GAAWxB,GAAkB,CACjCA,EAAEyB,gBAAe,EACjB,MAAMP,EAASlB,EAAEkB,OACd,CAAClB,EAAE0B,QAAUR,EAAOS,YAAcT,EAAOU,cAC1CV,EAAOW,YAAc7B,EAAE8B,OAAS,EAChC7B,EAAYD,CAAC,IAIX+B,EAAeA,IAAM,CACtB7G,GAAkBiE,GACnBf,KAIEvB,GAAgC,CACpC,IAAIH,gBAAiB,CACnB,OAAOA,EAAc,CACtB,EACD,IAAII,YAAa,CACf,OAAOA,EAAU,CAClB,EACD,IAAIC,YAAa,CACf,OAAOA,EAAU,CAClB,EACD,IAAIC,YAAa,CACf,OAAOA,EAAU,CAClB,EACDC,iBAAAA,EACA,IAAI+E,WAAY,CACd,OAAOrF,CACR,EACDoF,aAAAA,EACAlC,0BAAAA,IAGIoC,EAAmBC,GAAS,IAChCC,GACGtG,GAAkBuG,SAAQ,CAACvF,MAAOA,GAAK,IAAAqF,UAAA,CAAA,OACrClG,EAAMkG,QAAQ,CAAA,CAAA,CAGpB,EAEDG,GAAaC,GAAGL,EAAkBF,CAAY,CAAC,EAE/C,IAAIpF,EAAqBwC,EACzB,OAAA,IAAA,CAAA,MAAAoD,EAAAC,KAAAC,OAAAA,EAAAF,EAqBctG,QAAAA,IAAS,KAAO,CAACyG,IAAsBlB,IAAYmB,MAAS,EAAAF,EAAAF,EAD5D,SAAA,CAAChG,EAAmB,GAAI6B,CAAQ,EAAAwE,EAlBpCC,GAAS,CACblG,EAAMkG,EACL7G,EAAMW,MAAckG,CAAI,CAC1B,EAAAN,CAAA,EAAAO,EAAAP,EAkBArH,GAAkBe,IAAS,MAAG,IAAA,CAAA,MAAA8G,EAAAC,GAAA,EAAAC,EAAAF,EAAAG,WAAAD,OAAAA,EAAAE,YAQZlC,GAAgB2B,EAJvBQ,GAAO,CACXjE,EAAWiE,EACXpH,EAAMmD,WAAWiE,CAAE,CACpB,EAAAH,CAAA,EAAAF,IAIN,EAAA,IAAA,EAAAD,EAAAP,EACAN,EAAgB,IAAA,EAAAoB,OAAAC,GAAAf,EA7BVgB,GACL,aACC,cAAatH,CAAK,GACnBD,EAAMwH,MACNxH,EAAMyH,UAAY,WAClBC,IAAa,CAACC,IAAoB,eAClC,GAAI3H,EAAMqE,YAAc,CACtBzC,EAAiB,GAAM,iBACvBE,EAAiB,GAAI,eACrB7B,IAAS,KAAO,yBACfD,EAAMqE,cAAgB,OAASrE,EAAMqE,cAAgB,SAAW,6BAChErE,EAAMqE,cAAgB,UAAYrE,EAAMqE,cAAgB,SAAW,8BAA8B,EAChG,EACL,CAAA,CAAA,EAAAkC,CAAA,IAmBP,CAACqB,GAAA,CAAA,WAAA,CAAA"}